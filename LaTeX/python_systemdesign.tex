%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large System Design}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 1: Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why System Design?}

      \begin{itemize}
		\item Comprehensive guide to system design concepts
		\item From fundamentals to Implementations
		\item Real-world scalability challenges
	  \end{itemize}

\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{sysdesign1}

{\tiny (Ref: https://www.youtube.com/watch?v=BTjxUS\_PylA)}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 2: Requirements Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Requirements Analysis: Foundation of Design}

      \begin{itemize}
		\item \textbf{Functional Requirements}: What system should do (features, APIs, flows)
		\item \textbf{Non-Functional Requirements}: How system should perform (latency, availability, consistency)
		\item \textbf{Capacity Estimation}: Users, requests/sec, storage needs, bandwidth
		\item \textbf{Constraints}: Budget, timeline, existing infrastructure
		\item Always clarify ambiguities before diving into design
	  \end{itemize}

\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{sysdesign2}

{\tiny (Ref: http://www.crvs-dgb.org/en/activities/analysis-and-design/8-define-system-requirements/)}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 3: Scalability Fundamentals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Scalability: Growing Your System}
      \begin{itemize}
		\item \textbf{Vertical Scaling}: Add more resources (CPU, RAM) to single machine - simple but limited
		\item \textbf{Horizontal Scaling}: Add more machines - unlimited growth, requires coordination
		\item \textbf{Stateless Services}: Enable easy horizontal scaling by removing server-side session state
		\item \textbf{Sharding/Partitioning}: Split data across multiple databases
		\item \textbf{Microservices}: Decompose monolith into independent, scalable services
	  \end{itemize}

\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{sysdesign3}

{\tiny (Ref: https://www.linkedin.com/pulse/system-design-horizontal-scaling-vs-vertical-harsh-kumar-sharma-jadpf/)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 4: Caching Strategies
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Caching: Speed Through Memory}

      \begin{itemize}
		\item \textbf{Cache-Aside}: App checks cache first, loads from DB on miss, updates cache
		\item \textbf{Write-Through}: Write to cache and DB simultaneously - consistent but slower writes
		\item \textbf{Write-Back}: Write to cache only, async persist to DB - fast but risk data loss
		\item \textbf{Eviction Policies}: LRU, LFU, FIFO for managing limited cache space
		\item \textbf{CDN}: Cache static content geographically close to users
		\item Tools: Redis, Memcached, Varnish
	  \end{itemize}
	  
\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{sysdesign4}

{\tiny (Ref: https://www.geeksforgeeks.org/system-design/caching-system-design-concept-for-beginners/)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 5: Load Balancing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Load Balancing: Distributing Traffic}

      \begin{itemize}
		\item \textbf{Round Robin}: Distribute requests equally across servers
		\item \textbf{Least Connections}: Route to server with fewest active connections
		\item \textbf{IP Hash}: Consistent routing based on client IP for session affinity
		\item \textbf{Weighted}: Assign more traffic to powerful servers
		\item \textbf{Layer 4 vs Layer 7}: Network layer (TCP/UDP) vs Application layer (HTTP)
		\item Tools: Nginx, HAProxy, AWS ELB, Cloud Load Balancers
	  \end{itemize}

\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{sysdesign5}

{\tiny (Ref: https://www.geeksforgeeks.org/computer-networks/load-balancing-approach-in-distributed-system/)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 6: Database Design - SQL vs NoSQL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Database Design: Choosing the Right Store}

      \begin{itemize}
		\item \textbf{SQL (RDBMS)}: ACID, complex queries, relationships - MySQL
		\item \textbf{NoSQL Key-Value}: High performance, simple lookups - Redis
		\item \textbf{NoSQL Document}: Flexible schema, JSON - MongoDB, Couchbase
		\item \textbf{NoSQL Column-Family}: Time-series, analytics - Cassandra, HBase
		\item \textbf{NoSQL Graph}: Relationships, social networks - Neo4j
		\item Choose based on: consistency needs, query patterns, scale requirements
	  \end{itemize}

\begin{center}
\includegraphics[width=0.5\linewidth,keepaspectratio]{sysdesign6}

{\tiny (Ref: https://www.geeksforgeeks.org/computer-networks/load-balancing-approach-in-distributed-system/)}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 7: Database Scalability Patterns
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Database Scalability: Handling Growth}

      \begin{itemize}
		\item \textbf{Replication}: Master-slave for read scaling, Multi-master for write scaling
		\item \textbf{Sharding/Partitioning}: Horizontal split by key range, hash, or geography
		\item \textbf{Indexing}: B-trees for fast lookups, trade-off with write speed
		\item \textbf{Denormalization}: Duplicate data to avoid expensive joins
		\item \textbf{Connection Pooling}: Reuse database connections to reduce overhead
		\item CAP Theorem: Choose 2 of Consistency, Availability, Partition Tolerance
	  \end{itemize}

\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{sysdesign7}

{\tiny (Ref: https://medium.com/@hksrise/understanding-sharding-in-system-design-a-key-to-scalability-214ad71784c4)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 8: API Design Principles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{API Design: Building Interfaces}


      \begin{itemize}
		\item \textbf{REST}: Resource-based, HTTP methods (GET, POST, PUT, DELETE), stateless
		\item \textbf{GraphQL}: Flexible queries, single endpoint, client defines response structure
		\item \textbf{gRPC}: High performance, Protocol Buffers, bidirectional streaming
		\item \textbf{Versioning}: URL path (/v1/), header, or query parameter
		\item \textbf{Pagination}: Limit/offset or cursor-based for large datasets
		\item \textbf{Error Handling}: Consistent HTTP status codes and error messages
	  \end{itemize}

\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{sysdesign8}

{\tiny (Ref: https://www.geeksforgeeks.org/system-design/what-is-api-gateway-system-design/)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 9: Advanced Patterns - Message Queues
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Message Queues: Asynchronous Processing}

      \begin{itemize}
		\item \textbf{Purpose}: Decouple services, handle traffic spikes, reliable delivery
		\item \textbf{Patterns}: Point-to-point (Queue), Publish-Subscribe (Topic)
		\item \textbf{Guarantees}: At-least-once, at-most-once, exactly-once delivery
		\item \textbf{Use Cases}: Order processing, email notifications, video encoding
		\item \textbf{Tools}: Kafka (high throughput), RabbitMQ (flexible), AWS SQS/SNS
		\item Consider: message ordering, idempotency, dead letter queues
	  \end{itemize}

\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{sysdesign9}

{\tiny (Ref: https://www.geeksforgeeks.org/system-design/message-queues-system-design/)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 10: Monitoring and Observability
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Monitoring: Know Your System Health}

      \begin{itemize}
		\item \textbf{Metrics}: CPU, memory, disk, request rate, latency (p50, p99), error rate
		\item \textbf{Logging}: Structured logs, centralized aggregation, log levels
		\item \textbf{Tracing}: Distributed tracing for microservices (Jaeger, Zipkin)
		\item \textbf{Alerting}: Threshold-based, anomaly detection, on-call rotation
		\item \textbf{Dashboards}: Real-time visualization (Grafana, Datadog)
		\item SLIs, SLOs, SLAs: Define reliability targets
	  \end{itemize}

\begin{center}
\includegraphics[width=0.5\linewidth,keepaspectratio]{sysdesign10}

{\tiny (Ref: https://distributedcomputing.dev/SystemDesign/ObservabilityEngineering)}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 11: Project - URL Shortener (TinyURL)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Project: URL Shortener Design}

      \begin{itemize}
		\item \textbf{Requirements}: Shorten URLs, redirect, analytics, 100M URLs, low latency
		\item \textbf{Hashing}: Base62 encoding (a-zA-Z0-9) of counter or MD5/SHA hash
		\item \textbf{Database}: Key-value store (shortURL â†’ longURL), with index on shortURL
		\item \textbf{Caching}: Redis for hot URLs (80/20 rule), cache-aside pattern
		\item \textbf{API}: POST /shorten \{longURL\}, GET /:shortURL (302 redirect)
		\item \textbf{Scale}: DB sharding by hash, read replicas, CDN for static assets
	  \end{itemize}

\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{sysdesign11}

{\tiny (Ref: https://www.geeksforgeeks.org/system-design/system-design-url-shortening-service/)}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Slide 12: Project - API Rate Limiter
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Project: API Rate Limiter Design}

      % \begin{itemize}
		% \item \textbf{Purpose}: Prevent abuse, ensure fair usage, protect backend resources
		% \item \textbf{Token Bucket}: Refill tokens at fixed rate, consume per request - smooth traffic
		% \item \textbf{Sliding Window}: Count requests in rolling time window - precise but memory-intensive
		% \item \textbf{Fixed Window}: Count in fixed intervals - simple but burst at boundaries
		% \item \textbf{Implementation}: Redis with INCR/EXPIRE for counters, Lua scripts for atomicity
		% \item \textbf{Response}: 429 Too Many Requests, X-RateLimit headers
	  % \end{itemize}

% \begin{center}
% \includegraphics[width=0.5\linewidth,keepaspectratio]{sysdesign12}

% {\tiny (Ref: https://distributedcomputing.dev/SystemDesign/ObservabilityEngineering)}
% \end{center}

% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 13: System Design Framework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{System Design: Structured Approach}

      \begin{itemize}
		\item \textbf{Step 1}: Clarify requirements (functional, non-functional, scale)
		\item \textbf{Step 2}: Capacity estimation (storage, bandwidth, QPS)
		\item \textbf{Step 3}: High-level design (draw boxes and arrows)
		\item \textbf{Step 4}: Deep dive into components (database choice, caching)
		\item \textbf{Step 5}: Identify bottlenecks and optimize
		\item \textbf{Step 6}: Discuss trade-offs (consistency vs availability)
		\item Think aloud, communicate clearly, consider multiple solutions
	  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 14: Common Design Patterns Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Design Patterns: Quick Reference}

      \begin{itemize}
		\item \textbf{Circuit Breaker}: Stop calling failing service, prevent cascading failures
		\item \textbf{CQRS}: Separate read and write models for different optimization
		\item \textbf{Event Sourcing}: Store state changes as events, rebuild state by replay
		\item \textbf{Saga Pattern}: Manage distributed transactions across microservices
		\item \textbf{Bulkhead}: Isolate resources to prevent total system failure
		\item \textbf{Strangler Fig}: Gradually replace legacy system
	  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 15: Conclusion and Resources
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Conclusion: Mastering System Design}

      \begin{itemize}
		\item Practice with real systems: Twitter, Netflix, Uber designs
		\item Understand trade-offs, not just solutions
		\item Keep learning: new technologies, patterns emerge constantly
		\item Resources: "Designing Data-Intensive Applications", System Design Primer (GitHub)
		\item Mock interviews: Practice communication and thinking process
		\item Remember: No perfect design, only appropriate design for requirements
	  \end{itemize}

\end{frame}