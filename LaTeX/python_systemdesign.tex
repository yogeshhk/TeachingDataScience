%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large System Design}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 1: Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why System Design?}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item Comprehensive guide to system design concepts
		\item From fundamentals to Implementations
		\item Real-world scalability challenges
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 2: Requirements Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Requirements Analysis: Foundation of Design}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Functional Requirements}: What system should do (features, APIs, user flows)
		\item \textbf{Non-Functional Requirements}: How system should perform (latency, availability, consistency)
		\item \textbf{Capacity Estimation}: Users, requests/sec, storage needs, bandwidth
		\item \textbf{Constraints}: Budget, timeline, existing infrastructure
		\item Always clarify ambiguities before diving into design
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 3: Scalability Fundamentals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Scalability: Growing Your System}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Vertical Scaling}: Add more resources (CPU, RAM) to single machine - simple but limited
		\item \textbf{Horizontal Scaling}: Add more machines - unlimited growth, requires coordination
		\item \textbf{Stateless Services}: Enable easy horizontal scaling by removing server-side session state
		\item \textbf{Sharding/Partitioning}: Split data across multiple databases
		\item \textbf{Microservices}: Decompose monolith into independent, scalable services
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 4: Caching Strategies
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Caching: Speed Through Memory}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Cache-Aside}: App checks cache first, loads from DB on miss, updates cache
		\item \textbf{Write-Through}: Write to cache and DB simultaneously - consistent but slower writes
		\item \textbf{Write-Back}: Write to cache only, async persist to DB - fast but risk data loss
		\item \textbf{Eviction Policies}: LRU, LFU, FIFO for managing limited cache space
		\item \textbf{CDN}: Cache static content geographically close to users
		\item Tools: Redis, Memcached, Varnish
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 5: Load Balancing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Load Balancing: Distributing Traffic}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Round Robin}: Distribute requests equally across servers
		\item \textbf{Least Connections}: Route to server with fewest active connections
		\item \textbf{IP Hash}: Consistent routing based on client IP for session affinity
		\item \textbf{Weighted}: Assign more traffic to powerful servers
		\item \textbf{Layer 4 vs Layer 7}: Network layer (TCP/UDP) vs Application layer (HTTP)
		\item Tools: Nginx, HAProxy, AWS ELB, Cloud Load Balancers
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 6: Database Design - SQL vs NoSQL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Database Design: Choosing the Right Store}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{SQL (RDBMS)}: ACID, complex queries, relationships - PostgreSQL, MySQL
		\item \textbf{NoSQL Key-Value}: High performance, simple lookups - Redis, DynamoDB
		\item \textbf{NoSQL Document}: Flexible schema, JSON - MongoDB, Couchbase
		\item \textbf{NoSQL Column-Family}: Time-series, analytics - Cassandra, HBase
		\item \textbf{NoSQL Graph}: Relationships, social networks - Neo4j
		\item Choose based on: consistency needs, query patterns, scale requirements
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 7: Database Scalability Patterns
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Database Scalability: Handling Growth}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Replication}: Master-slave for read scaling, Multi-master for write scaling
		\item \textbf{Sharding/Partitioning}: Horizontal split by key range, hash, or geography
		\item \textbf{Indexing}: B-trees for fast lookups, trade-off with write speed
		\item \textbf{Denormalization}: Duplicate data to avoid expensive joins
		\item \textbf{Connection Pooling}: Reuse database connections to reduce overhead
		\item CAP Theorem: Choose 2 of Consistency, Availability, Partition Tolerance
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 8: API Design Principles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{API Design: Building Interfaces}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{REST}: Resource-based, HTTP methods (GET, POST, PUT, DELETE), stateless
		\item \textbf{GraphQL}: Flexible queries, single endpoint, client defines response structure
		\item \textbf{gRPC}: High performance, Protocol Buffers, bidirectional streaming
		\item \textbf{Versioning}: URL path (/v1/), header, or query parameter
		\item \textbf{Pagination}: Limit/offset or cursor-based for large datasets
		\item \textbf{Error Handling}: Consistent HTTP status codes and error messages
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 9: Advanced Patterns - Message Queues
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Message Queues: Asynchronous Processing}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Purpose}: Decouple services, handle traffic spikes, reliable delivery
		\item \textbf{Patterns}: Point-to-point (Queue), Publish-Subscribe (Topic)
		\item \textbf{Guarantees}: At-least-once, at-most-once, exactly-once delivery
		\item \textbf{Use Cases}: Order processing, email notifications, video encoding
		\item \textbf{Tools}: Kafka (high throughput), RabbitMQ (flexible), AWS SQS/SNS
		\item Consider: message ordering, idempotency, dead letter queues
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 10: Monitoring and Observability
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Monitoring: Know Your System Health}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Metrics}: CPU, memory, disk, request rate, latency (p50, p99), error rate
		\item \textbf{Logging}: Structured logs, centralized aggregation, log levels
		\item \textbf{Tracing}: Distributed tracing for microservices (Jaeger, Zipkin)
		\item \textbf{Alerting}: Threshold-based, anomaly detection, on-call rotation
		\item \textbf{Dashboards}: Real-time visualization (Grafana, Datadog)
		\item SLIs, SLOs, SLAs: Define reliability targets
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 11: Project - URL Shortener (TinyURL)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Project: URL Shortener Design}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Requirements}: Shorten URLs, redirect, analytics, 100M URLs, low latency
		\item \textbf{Hashing}: Base62 encoding (a-zA-Z0-9) of counter or MD5/SHA hash
		\item \textbf{Database}: Key-value store (shortURL â†’ longURL), with index on shortURL
		\item \textbf{Caching}: Redis for hot URLs (80/20 rule), cache-aside pattern
		\item \textbf{API}: POST /shorten \{longURL\}, GET /:shortURL (302 redirect)
		\item \textbf{Scale}: DB sharding by hash, read replicas, CDN for static assets
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 12: Project - API Rate Limiter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Project: API Rate Limiter Design}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Purpose}: Prevent abuse, ensure fair usage, protect backend resources
		\item \textbf{Token Bucket}: Refill tokens at fixed rate, consume per request - smooth traffic
		\item \textbf{Sliding Window}: Count requests in rolling time window - precise but memory-intensive
		\item \textbf{Fixed Window}: Count in fixed intervals - simple but burst at boundaries
		\item \textbf{Implementation}: Redis with INCR/EXPIRE for counters, Lua scripts for atomicity
		\item \textbf{Response}: 429 Too Many Requests, X-RateLimit headers
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 13: System Design Framework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{System Design: Structured Approach}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Step 1}: Clarify requirements (functional, non-functional, scale)
		\item \textbf{Step 2}: Capacity estimation (storage, bandwidth, QPS)
		\item \textbf{Step 3}: High-level design (draw boxes and arrows)
		\item \textbf{Step 4}: Deep dive into components (database choice, caching)
		\item \textbf{Step 5}: Identify bottlenecks and optimize
		\item \textbf{Step 6}: Discuss trade-offs (consistency vs availability)
		\item Think aloud, communicate clearly, consider multiple solutions
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 14: Common Design Patterns Summary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Design Patterns: Quick Reference}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item \textbf{Circuit Breaker}: Stop calling failing service, prevent cascading failures
		\item \textbf{CQRS}: Separate read and write models for different optimization
		\item \textbf{Event Sourcing}: Store state changes as events, rebuild state by replay
		\item \textbf{Saga Pattern}: Manage distributed transactions across microservices
		\item \textbf{Bulkhead}: Isolate resources to prevent total system failure
		\item \textbf{Strangler Fig}: Gradually replace legacy system
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 15: Conclusion and Resources
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Conclusion: Mastering System Design}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
		\item Practice with real systems: Twitter, Netflix, Uber designs
		\item Understand trade-offs, not just solutions
		\item Keep learning: new technologies, patterns emerge constantly
		\item Resources: "Designing Data-Intensive Applications", System Design Primer (GitHub)
		\item Mock interviews: Practice communication and thinking process
		\item Remember: No perfect design, only appropriate design for requirements
	  \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}
\end{center}
    \end{column}
  \end{columns}
\end{frame}