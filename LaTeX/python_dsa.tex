%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Data Structures and Algorithms}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Slide 1: Title Slide
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Data Structures \& Algorithms in Python}
% \begin{center}
% {\Large From Basics to Advanced}\\[1cm]
% {\large A Comprehensive Guide}\\[0.5cm]
% \includegraphics[width=0.4\linewidth,keepaspectratio]{YHK_Color_OutOfTheBox}\\[0.5cm]
% {\normalsize Master DSA with Python\\
% LeetCode Patterns \& Problem Solving}
% \end{center}
% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 2: Course Overview
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Course Overview}

      \begin{itemize}
        \item Fundamental Data Structures
        \item Core Algorithms \& Techniques
        \item Time \& Space Complexity Analysis
        \item 8 Essential LeetCode Patterns
        \item Real-world Problem Solving
        \item Best Practices \& Optimization
      \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 3: Arrays Basics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Arrays \& Lists - Fundamentals}
\begin{columns}
    \begin{column}[T]{0.7\linewidth}
      \begin{itemize}
        \item Dynamic arrays in Python (lists)
        \item O(1) access by index
        \item O(n) insertion/deletion (worst case)
        \item Contiguous memory allocation
        \item Common operations: append, insert, remove
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa13}


{\tiny (Ref: https://www.geeksforgeeks.org/python/python-lists/)}
\end{center}
	  
    \end{column}
    \begin{column}[T]{0.3\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# List creation
arr = [1, 2, 3, 4, 5]

# Access - O(1)
print(arr[0])  # 1

# Append - O(1) amortized
arr.append(6)

# Insert - O(n)
arr.insert(0, 0)

# Delete - O(n)
arr.remove(3)

# Slicing
sub = arr[1:4]
      \end{lstlisting}

    \end{column}
  \end{columns}
  

  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 4: List Comprehensions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{List Comprehensions \& Advanced Operations}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Pythonic way to create lists
        \item More readable and faster
        \item Supports filtering and mapping
        \item Can handle nested structures
        \item Essential for interview coding
      \end{itemize}
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Basic comprehension
squares = [x**2 for x in range(10)]

# With condition
evens = [x for x in range(20) if x % 2 == 0]

# Nested comprehension
matrix = [[i*j for j in range(3)] 
          for i in range(3)]

# Map-like operation
names = ['alice', 'bob']
upper = [n.upper() for n in names]

# Filter and transform
nums = [1, -2, 3, -4]
positive_sq = [x**2 for x in nums if x > 0]
      \end{lstlisting}

    \end{column}
  \end{columns}
  
\vspace{0.4cm}

\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{dsa14}


{\tiny (Ref: https://www.listendata.com/2019/07/python-list-comprehension-with-examples.html)}
\end{center}  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 5: Hash Tables/Dictionaries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Hash Tables \& Dictionaries}
\begin{columns}
    \begin{column}[T]{0.7\linewidth}
      \begin{itemize}
        \item O(1) average lookup, insert, delete
        \item Key-value pairs storage
        \item Hash function maps keys to indices
        \item Handles collisions internally
        \item Most versatile data structure
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa15}


{\tiny (Ref: https://www.listendata.com/2019/07/python-list-comprehension-with-examples.html)}
\end{center}  
	  
    \end{column}
    \begin{column}[T]{0.3\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Dictionary creation
d = {'a': 1, 'b': 2}

# Access - O(1)
val = d.get('a', 0)  # Safe access

# Insert/Update - O(1)
d['c'] = 3

# Delete - O(1)
del d['b']

# Check existence
if 'a' in d:
    print(d['a'])

# Iterate
for key, val in d.items():
    print(f"{key}: {val}")

# defaultdict for cleaner code
from collections import defaultdict
count = defaultdict(int)
count['apple'] += 1
      \end{lstlisting}

    \end{column}
  \end{columns}
  
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 6: Sets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Sets - Unique Collections}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Unordered collection of unique items
        \item O(1) membership testing
        \item Efficient set operations (union, intersection)
        \item No duplicate elements
        \item Useful for deduplication
      \end{itemize}
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Set creation
s = {1, 2, 3, 4}
s = set([1, 2, 2, 3])  # {1, 2, 3}

# Add - O(1)
s.add(5)

# Remove - O(1)
s.discard(2)  # Safe remove
s.remove(3)   # Raises error if not found

# Membership - O(1)
if 4 in s:
    print("Found")

# Set operations
a = {1, 2, 3}
b = {3, 4, 5}
union = a | b        # {1,2,3,4,5}
intersection = a & b # {3}
difference = a - b   # {1,2}
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 7: Stacks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Stacks - LIFO Structure}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Last In First Out (LIFO) principle
        \item O(1) push and pop operations
        \item Used in recursion, parsing, backtracking
        \item Python list works perfectly as stack
        \item Common uses: expression evaluation, DFS
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa16}


{\tiny (Ref: https://www.programiz.com/dsa/stack)}
\end{center}  
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Stack using list
stack = []

# Push - O(1)
stack.append(1)
stack.append(2)
stack.append(3)

# Pop - O(1)
top = stack.pop()  # 3

# Peek
if stack:
    top = stack[-1]  # Don't remove

# Check if empty
is_empty = len(stack) == 0

# Valid Parentheses example
def isValid(s):
    stack = []
    pairs = {'(':')', '[':']', '{':'}'}
    for char in s:
        if char in pairs:
            stack.append(char)
        elif not stack or pairs[stack.pop()] != char:
            return False
    return len(stack) == 0
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 8: Queues
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Queues - FIFO Structure}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item First In First Out (FIFO) principle
        \item O(1) enqueue and dequeue with deque
        \item Used in BFS, scheduling, buffering
        \item collections.deque is optimal
        \item Supports operations at both ends
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa17}


{\tiny (Ref: https://www.programiz.com/dsa/queue)}
\end{center}  
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
from collections import deque

# Queue using deque
queue = deque()

# Enqueue - O(1)
queue.append(1)
queue.append(2)
queue.append(3)

# Dequeue - O(1)
first = queue.popleft()  # 1

# Peek front
if queue:
    front = queue[0]

# Peek back
if queue:
    back = queue[-1]

# BFS example
def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            queue.extend(graph[node])
    return visited
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 9: Linked Lists
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Linked Lists - Dynamic Structure}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Nodes connected via pointers
        \item O(1) insertion/deletion at known position
        \item O(n) search and access
        \item No contiguous memory required
        \item Types: singly, doubly, circular
      \end{itemize}
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Node definition
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Create linked list
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)

# Traverse
curr = head
while curr:
    print(curr.val)
    curr = curr.next

# Reverse linked list
def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 10: Binary Trees
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Binary Trees - Hierarchical Structure}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Each node has at most 2 children
        \item Root, internal nodes, and leaves
        \item Traversals: inorder, preorder, postorder
        \item Height: O(log n) balanced, O(n) worst
        \item Foundation for BST, heaps, etc.
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa18}


{\tiny (Ref: https://www.geeksforgeeks.org/python/binary-tree-in-python/)}
\end{center} 	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Tree node definition
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Inorder traversal (Left-Root-Right)
def inorder(root):
    if not root:
        return []
    return (inorder(root.left) + 
            [root.val] + 
            inorder(root.right))

# Level order traversal (BFS)
def levelOrder(root):
    if not root:
        return []
    result, queue = [], deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 11: Binary Search Trees
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Binary Search Trees (BST)}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Left subtree < root < right subtree
        \item O(log n) search, insert, delete (balanced)
        \item O(n) worst case (skewed tree)
        \item Inorder traversal gives sorted order
        \item Self-balancing variants: AVL, Red-Black
      \end{itemize}
	  
	  
\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{dsa19}


{\tiny (Ref: https://www.geeksforgeeks.org/dsa/introduction-to-binary-search-tree/)}
\end{center} 	  
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Search in BST
def searchBST(root, val):
    if not root or root.val == val:
        return root
    if val < root.val:
        return searchBST(root.left, val)
    return searchBST(root.right, val)

# Insert into BST
def insertBST(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = insertBST(root.left, val)
    else:
        root.right = insertBST(root.right, val)
    return root

# Validate BST
def isValidBST(root, min_val=float('-inf'), 
               max_val=float('inf')):
    if not root:
        return True
    if not (min_val < root.val < max_val):
        return False
    return (isValidBST(root.left, min_val, root.val) and
            isValidBST(root.right, root.val, max_val))
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 12: Heaps & Priority Queues
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Heaps \& Priority Queues}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Complete binary tree structure
        \item Min-heap: parent $\leq$ children
        \item Max-heap: parent $\geq$ children
        \item O(log n) insert and extract-min/max
        \item O(1) peek at min/max element
        \item Used in: Dijkstra, heap sort, scheduling
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{dsa20}


{\tiny (Ref: https://www.geeksforgeeks.org/dsa/introduction-to-binary-search-tree/)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
import heapq

# Min heap (default in Python)
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappush(heap, 8)

# Extract min - O(log n)
min_val = heapq.heappop(heap)  # 2

# Peek min - O(1)
if heap:
    min_val = heap[0]

# Heapify array - O(n)
arr = [5, 2, 8, 1, 9]
heapq.heapify(arr)

# Max heap (negate values)
max_heap = []
heapq.heappush(max_heap, -5)
max_val = -heapq.heappop(max_heap)

# K largest elements
def kLargest(nums, k):
    return heapq.nlargest(k, nums)
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 13: Graphs - Representation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Graphs - Representation}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Vertices (nodes) and edges (connections)
        \item Directed vs undirected
        \item Weighted vs unweighted
        \item Adjacency list: O(V+E) space
        \item Adjacency matrix: O(V²) space
        \item Most problems use adjacency list
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa21}


{\tiny (Ref: https://www.programiz.com/dsa/graph)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
from collections import defaultdict

# Adjacency list representation
graph = defaultdict(list)

# Add edge (undirected)
def add_edge(u, v):
    graph[u].append(v)
    graph[v].append(u)

# Add weighted edge
weighted_graph = defaultdict(list)
def add_weighted_edge(u, v, w):
    weighted_graph[u].append((v, w))
    weighted_graph[v].append((u, w))

# Example graph
add_edge(0, 1)
add_edge(0, 2)
add_edge(1, 2)
add_edge(2, 3)

# Adjacency matrix (for dense graphs)
n = 4
matrix = [[0]*n for _ in range(n)]
matrix[0][1] = matrix[1][0] = 1
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 14: Graph Traversals - DFS & BFS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Graph Traversals - DFS }
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item DFS: Depth First Search (stack/recursion)
        \item BFS: Breadth First Search (queue)
        \item $O(V + E)$ time complexity
        \item DFS for: cycles, topological sort, paths
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa22}


{\tiny (Ref: DFS https://medium.com/nerd-for-tech/graph-traversal-in-python-depth-first-search-dfs-ce791f48af5b)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# DFS - Recursive
def dfs(graph, node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

# DFS - Iterative
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            print(node)
            stack.extend(graph[node])
    return visited
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 14: Graph Traversals - DFS & BFS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Graph Traversals - BFS}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item BFS: Breadth First Search (queue)
        \item $O(V + E)$ time complexity
        \item BFS for: shortest path, level-order
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa23}


{\tiny (Ref: BFS https://medium.com/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]

# BFS
def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    while queue:
        node = queue.popleft()
        print(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return visited
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 15: Binary Search
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Binary Search Algorithm}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item O(log n) search in sorted array
        \item Divide and conquer approach
        \item Eliminates half of elements each step
        \item Must have sorted input
        \item Template applicable to many problems
        \item Find exact match or insertion point
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{dsa24}


{\tiny (Ref: BFS https://medium.com/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516)}
\end{center} 	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Standard binary search
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target: return mid
        elif arr[mid] < target:
            left = mid + 1
        else: right = mid - 1
    return -1

# Find insertion position
def searchInsert(nums, target):
    left, right = 0, len(nums)
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] < target: left = mid + 1
        else: right = mid
    return left

# Find first occurrence
def findFirst(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            result = mid
            right = mid - 1
        elif arr[mid] < target: left = mid + 1
        else: right = mid - 1
    return result
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 16: Sorting Algorithms - Part 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Sorting Algorithms - Comparison Based}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Quick Sort: O(n log n) avg, O(n²) worst
        \item Merge Sort: O(n log n) guaranteed
        \item Heap Sort: O(n log n), in-place
        \item Bubble/Insertion: O(n²), simple
        \item Python's sorted() uses Timsort
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.7\linewidth,keepaspectratio]{dsa25}


{\tiny (Ref: https://www.geeksforgeeks.org/dsa/introduction-to-sorting-algorithm/)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Quick Sort
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)

# Merge Sort
def mergesort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = mergesort(arr[:mid])
    right = mergesort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 17: Big O Complexity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Big O Notation - Time \& Space Complexity}
\begin{columns}
    \begin{column}[T]{0.65\linewidth}
      \begin{itemize}
        \item Measures algorithm efficiency
        \item $O(1)$: Constant time
        \item $O(log n)$: Logarithmic (binary search)
        \item $O(n)$: Linear (single loop)
        \item $O(n log n)$: Linearithmic (merge sort)
        \item $O(n^2)$: Quadratic (nested loops)
        \item $O(2^n)$: Exponential (recursion)
        \item Drop constants and lower order terms
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.6\linewidth,keepaspectratio]{dsa26}


{\tiny (Ref: https://medium.com/data-science/understanding-time-complexity-with-python-examples-2bda6e8158a7)}
\end{center} 	  
    \end{column}
    \begin{column}[T]{0.35\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
def get_first(arr): # O(1) - Constant
    return arr[0]

def find_max(arr): # O(n) - Linear
    max_val = arr[0]
    for num in arr:
        if num > max_val: max_val = num
    return max_val

def bubble_sort(arr): # O(n^2) - Quadratic
    n = len(arr)
    for i in range(n):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# O(log n) - Logarithmic
def binary_search(arr, target):
    left, right = 0, len(arr)-1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target: left = mid + 1
        else: right = mid - 1
    return -1

def fibonacci(n): # O(2^n) - Exponential
    if n <= 1: return n
    return fibonacci(n-1) + fibonacci(n-2)
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 18: Pattern 1 - Two Pointers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 1: Two Pointers Technique}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Use two pointers to iterate array
        \item Opposite direction or same direction
        \item O(n) time, O(1) space typically
        \item Common in: sorted arrays, palindromes
        \item Example: Two Sum II, Container With Most Water
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.5\linewidth,keepaspectratio]{dsa27}


{\tiny (Ref: https://emre.me/coding-patterns/two-pointers/)}
\end{center} 	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Two Sum II (sorted array)
# Given sorted array, find two numbers 
# that add up to target
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        curr_sum = numbers[left] + numbers[right]
        if curr_sum == target:
            return [left + 1, right + 1]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []

# Problem: Valid Palindrome
def isPalindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left += 1
        right -= 1
    return True
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 19: Pattern 2 - Sliding Window
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 2: Sliding Window}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Fixed or variable size window
        \item Maintains window state efficiently
        \item O(n) time for array/string problems
        \item Common in: subarray/substring problems
        \item Example: Max Sum Subarray, Longest Substring
      \end{itemize}
	  
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa28}


{\tiny (Ref: https://emre.me/coding-patterns/sliding-window/)}
\end{center} 
	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Max Sum of Subarray of Size K
def maxSumSubarray(arr, k):
    if len(arr) < k:
        return 0
    
    # Calculate sum of first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide window
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i-k] + arr[i]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# Problem: Longest Substring Without Repeating
def lengthOfLongestSubstring(s):
    char_set = set()
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 20: Pattern 3 - Fast & Slow Pointers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 3: Fast \& Slow Pointers (Floyd's Cycle)}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Two pointers moving at different speeds
        \item Detects cycles in linked lists
        \item Finds middle element efficiently
        \item O(n) time, O(1) space
        \item Example: Linked List Cycle, Happy Number
      \end{itemize}
	  
\begin{center}
\includegraphics[width=0.8\linewidth,keepaspectratio]{dsa29}


{\tiny (Ref: https://emre.me/coding-patterns/fast-slow-pointers/)}
\end{center} 	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
def hasCycle(head): # Problem: Detect Cycle in Linked List
    if not head or not head.next: return False
    slow = head
    fast = head.next
    while slow != fast:
        if not fast or not fast.next: return False
        slow = slow.next
        fast = fast.next.next
    return True
	
def middleNode(head): # Problem: Find Middle of Linked List
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow

def isHappy(n): # Problem: Happy Number
    def get_next(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit ** 2
            num //= 10
        return total
    slow = n
    fast = get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 21: Pattern 4 - Merge Intervals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 4: Merge Intervals}
\begin{columns}
    \begin{column}[T]{0.4\linewidth}
      \begin{itemize}
        \item Sort intervals by start time
        \item Merge overlapping intervals
        \item O(n log n) time due to sorting
        \item Common in: scheduling, ranges
        \item Example: Merge Intervals, Insert Interval
      \end{itemize}


    \end{column}
    \begin{column}[T]{0.6\linewidth}
\begin{center}
\includegraphics[width=\linewidth,keepaspectratio]{dsa30}


{\tiny (Ref: https://www.w3resource.com/data-structures-and-algorithms/array/dsa-merge-intervals.php)}
\end{center} 
	  
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 21: Pattern 4 - Merge Intervals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 4: Merge Intervals}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
	
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Merge Overlapping Intervals
def merge(intervals):
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            # Overlapping, merge
            last[1] = max(last[1], current[1])
        else:
            # Non-overlapping, add
            merged.append(current)
    
    return merged

      \end{lstlisting}
	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]

# Problem: Insert Interval
def insert(intervals, newInterval):
    result = []
    i = 0
    n = len(intervals)
    
    # Add all intervals before newInterval
    while i < n and intervals[i][1] < newInterval[0]:
        result.append(intervals[i])
        i += 1
    
    # Merge overlapping intervals
    while i < n and intervals[i][0] <= newInterval[1]:
        newInterval[0] = min(newInterval[0], intervals[i][0])
        newInterval[1] = max(newInterval[1], intervals[i][1])
        i += 1
    result.append(newInterval)
    
    # Add remaining intervals
    result.extend(intervals[i:])
    return result
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 22: Pattern 5 - Cyclic Sort
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 5: Cyclic Sort}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item For arrays with numbers in range [1, n]
        \item Place each number at its correct index
        \item O(n) time, O(1) space
        \item Finds missing/duplicate numbers
        \item Example: Find Missing Number, First Missing Positive
      \end{itemize}
	  

    \end{column}
    \begin{column}[T]{0.5\linewidth}
\begin{center}
\includegraphics[width=0.55\linewidth,keepaspectratio]{dsa31}


{\tiny (Ref: paulonteri/data-structures-and-algorithms)}
\end{center} 
	  
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 22: Pattern 5 - Cyclic Sort
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 5: Cyclic Sort}
\begin{columns}
    \begin{column}[T]{0.6\linewidth}
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Find Missing Number (0 to n)
def missingNumber(nums):
    i = 0
    n = len(nums)
    
    while i < n:
        correct_idx = nums[i]
        if nums[i] < n and nums[i] != nums[correct_idx]:
            # Swap to correct position
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    # Find first missing
    for i in range(n):
        if nums[i] != i:
            return i
    return n
      \end{lstlisting}	  
    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]

# Problem: Find All Duplicates (1 to n)
def findDuplicates(nums):
    i = 0
    while i < len(nums):
        correct_idx = nums[i] - 1
        if nums[i] != nums[correct_idx]:
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
            i += 1
    
    duplicates = []
    for i in range(len(nums)):
        if nums[i] != i + 1:
            duplicates.append(nums[i])
    
    return duplicates
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 23: Pattern 6 - In-place Reversal of Linked List
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 6: In-place Reversal of Linked List}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Reverse links without extra space
        \item Three pointers: prev, curr, next
        \item O(n) time, O(1) space
        \item Fundamental for many LL problems
        \item Example: Reverse Linked List, Reverse in K-Group
      \end{itemize}
	  
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Reverse Linked List
def reverseList(head):
    prev = None
    curr = head
    
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    
    return prev
      \end{lstlisting}
	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Reverse Linked List II 
# (from position left to right)
def reverseBetween(head, left, right):
    if not head or left == right:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    
    # Move to position before left
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse from left to right
    curr = prev.next
    for _ in range(right - left):
        next_temp = curr.next
        curr.next = next_temp.next
        next_temp.next = prev.next
        prev.next = next_temp
    
    return dummy.next
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 24: Pattern 7 - Tree BFS (Level Order)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 7: Tree BFS (Level Order Traversal)}
      \begin{itemize}
        \item Use queue for level-by-level traversal
        \item Process nodes at same level together
        \item O(n) time, O(w) space (w = max width)
        % \item Common in: level-based tree problems
        \item Example: Level Order, Zigzag Traversal
      \end{itemize}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
from collections import deque

# Problem: Binary Tree Level Order Traversal
def levelOrder(root):
    if not root: return []
    
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        current_level = []
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        
        result.append(current_level)
    
    return result
      \end{lstlisting}
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Zigzag Level Order Traversal
def zigzagLevelOrder(root):
    if not root: return []
    
    result = []
    queue = deque([root])
    left_to_right = True
    
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        
        if not left_to_right: level.reverse()
        result.append(level)
        left_to_right = not left_to_right
    
    return result
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 25: Pattern 8 - Tree DFS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Pattern 8: Tree DFS (Depth First Search)}

\begin{columns}
    \begin{column}[T]{0.6\linewidth}
      \begin{itemize}
        \item Recursion or stack for deep traversal
        \item Preorder, Inorder, Postorder variants
        \item O(n) time, O(h) space (h = height)
        \item Common in: path problems, subtree checks
        \item Example: Max Depth, Path Sum, Diameter
      \end{itemize}
	  
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Maximum Depth of Binary Tree
def maxDepth(root):
    if not root:
        return 0
    left_depth = maxDepth(root.left)
    right_depth = maxDepth(root.right)
    return 1 + max(left_depth, right_depth)
      \end{lstlisting}

    \end{column}
    \begin{column}[T]{0.4\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Path Sum
def hasPathSum(root, targetSum):
    if not root:
        return False
    
    if not root.left and not root.right:
        return root.val == targetSum
    
    targetSum -= root.val
    return (hasPathSum(root.left, targetSum) or 
            hasPathSum(root.right, targetSum))

# Problem: Diameter of Binary Tree
def diameterOfBinaryTree(root):
    diameter = 0
    
    def height(node):
        nonlocal diameter
        if not node:
            return 0
        
        left = height(node.left)
        right = height(node.right)
        diameter = max(diameter, left + right)
        
        return 1 + max(left, right)
    
    height(root)
    return diameter
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 26: Dynamic Programming - Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dynamic Programming - Foundations}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Break problem into overlapping subproblems
        \item Store solutions to avoid recomputation
        \item Top-down (memoization) or bottom-up (tabulation)
        \item Identify: optimal substructure + overlapping subproblems
        \item Example: Fibonacci, Climbing Stairs
      \end{itemize}

     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Fibonacci - Naive (exponential)
def fib_naive(n):
    if n <= 1:
        return n
    return fib_naive(n-1) + fib_naive(n-2)
      \end{lstlisting}
	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Fibonacci - Memoization (top-down)
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# Fibonacci - Tabulation (bottom-up)
def fib_tab(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# Fibonacci - Space Optimized
def fib_optimal(n):
    if n <= 1:
        return n
    prev, curr = 0, 1
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    return curr
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 27: Dynamic Programming - Classic Problems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dynamic Programming - Classic Problems}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Coin Change: min coins for amount
        \item Longest Common Subsequence (LCS)
        \item 0/1 Knapsack Problem
        \item House Robber variations
        \item Edit Distance
      \end{itemize}
	  
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Coin Change
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
      \end{lstlisting}	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Longest Common Subsequence
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Problem: House Robber
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    prev2, prev1 = 0, 0
    for num in nums:
        temp = prev1
        prev1 = max(prev2 + num, prev1)
        prev2 = temp
    
    return prev1
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 28: Backtracking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Backtracking - Exhaustive Search}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Try all possibilities recursively
        \item Prune invalid paths early
        \item Build solution incrementally
        \item Undo choices (backtrack) when needed
        \item Example: Permutations, Subsets, N-Queens
      \end{itemize}
	  
     \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Generate All Subsets
def subsets(nums):
    result = []
    
    def backtrack(start, path):
        result.append(path[:])
        
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()  # Backtrack
    
    backtrack(0, [])
    return result
      \end{lstlisting}
	  
    \end{column}
    \begin{column}[T]{0.5\linewidth}
      \begin{lstlisting}[language=python, basicstyle=\tiny]
# Problem: Permutations
def permute(nums):
    result = []
    
    def backtrack(path, remaining):
        if not remaining:
            result.append(path[:])
            return
        
        for i in range(len(remaining)):
            backtrack(path + [remaining[i]], 
                     remaining[:i] + remaining[i+1:])
    
    backtrack([], nums)
    return result

# Problem: Combination Sum
def combinationSum(candidates, target):
    result = []
    def backtrack(start, path, total):
        if total == target:
            result.append(path[:])
            return
        if total > target:  return
        
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(i, path, total + candidates[i])
            path.pop()
    
    backtrack(0, [], 0)
    return result
      \end{lstlisting}

    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 29: Advanced Topics Overview
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Advanced Topics \& Techniques}

      \begin{itemize}
        \item Trie (Prefix Tree) for string problems
        \item Union-Find for connected components
        \item Topological Sort for DAGs
        \item Dijkstra's \& Bellman-Ford for shortest paths
        \item Bit Manipulation tricks
        \item Greedy algorithms
        \item Monotonic Stack/Queue
      \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Slide 30: Conclusion & Best Practices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Conclusion \& Best Practices}

      \begin{itemize}
        \item Start with brute force, then optimize
        \item Identify pattern before coding
        \item Draw diagrams for complex problems
        \item Test with edge cases
        \item Analyze time \& space complexity
        \item Practice consistently on LeetCode
        \item Master the 8 common patterns
        \item Review and learn from solutions
      \end{itemize}
 
\end{frame}