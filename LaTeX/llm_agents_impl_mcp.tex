%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Model Context Protocol (MCP)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{LLMs Alone Aren't Enough}

\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Real AI apps need search, tools, memory, and APIs
        \item LLMs can't handle complex tasks on their own
        \item Integration quickly becomes messy and fragile
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents9}
		\end{center}
    \end{column}
  \end{columns}
   
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{The Integration Problem}

\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Every feature requires custom wrappers
        \item Updates often break existing logic
        \item M apps $\times$ N tools = scaling nightmare
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents11}
		\end{center}
    \end{column}
  \end{columns}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Enter MCP: USB-C for AI}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Shared protocol for AI-to-tool connections
        \item One-time tool exposure works with all models
        \item No wrappers, less chaos, easy reuse
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents10}
		\end{center}
    \end{column}
  \end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{How MCP Works?}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Host: the AI app (e.g., Claude Desktop)
        \item Client: bridge that speaks MCP
        \item Server: where tools, files, prompts live
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents12}
		\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Clean, Typed Communication}
\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item Uses JSON-RPC for structured messaging
        \item Modular design enables reuse
        \item Protocol simplifies complex system behavior
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents13}
		\end{center}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{From Demos to Real Systems}

\begin{columns}
    \begin{column}[T]{0.5\linewidth}
      \begin{itemize}
        \item MCP transforms fragile demos into scalable systems
        \item Reduces engineering overhead
        \item Enables AI software that ships and lasts
      \end{itemize}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents17}
		
		{\tiny (Ref: Agentic AI For Everyone - Aish \& Kiriti)}
		\end{center}
    \end{column}
  \end{columns}
  
	
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{So, what is MCP?}
      \begin{itemize}
        \item A standardized way to deliver full context to an LLM
        \item Includes task, tools, memory, documents, and prior messages
        \item Acts like a structured input package for the model
        \item Similar to protocols like HTTP or TCP/IP — not a product
        \item Enables clean communication between model and system
      \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why MCP Matters}
      \begin{itemize}
        \item Avoids reinventing prompt logic for every use case
        \item Standardizes context delivery for agents
        \item Simplifies managing memory, tools, and state
        \item Enables modular, composable orchestration
        \item Think of it as a structured request schema for LLMs
      \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{How MCP Helps in Practice}
      \begin{itemize}
        \item Reduces chaos in multi-tool, multi-context systems
        \item Makes integration with RAG, memory, and outputs cleaner
        \item Easier to plug agents into enterprise pipelines
        \item Moves away from dumping long prompts into the model
        \item Structured text input improves grounding and clarity
      \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why MCP Gained Traction}
      \begin{itemize}
        \item AI-native: designed for agents, tools, memory, and more
        \item Strong initial documentation and real examples
        \item Released SDKs, testing tools, and demos
        \item Quiet launch in 2024; exploded in 2025 adoption
        \item Broad support from OpenAI, startups, and platforms
      \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Common Misunderstandings}
      \begin{itemize}
        \item MCP is not a new API or product
        \item It doesn’t make models smarter — just clearer context
        \item Useful beyond agents — assistants benefit too
        \item Helps structure evolving context, not static prompts
      \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Should You Care About MCP?}
      \begin{itemize}
        \item Not essential for simple demos or toy prompts
        \item Crucial for enterprise-grade agent systems
        \item Helps with multi-tool, RAG, memory, and planning workflows
        \item Improves long-term context management and scale
        \item Adoption is key — like any protocol, usage defines value
      \end{itemize}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{MCP: From Demos to Real Systems}

\begin{columns}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents14}
		\end{center}

    \end{column}
    \begin{column}[T]{0.5\linewidth}
		\begin{center}
		\includegraphics[width=\linewidth,keepaspectratio]{aiagents15}
		\end{center}
    \end{column}
  \end{columns}
  


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Some Opposition to MCP \ldots}
    \begin{itemize}
        \item Fancy acronyms often solve imaginary problems
        \item Overengineered MCP layers complicate agent-API flow
        \item Hype drives architecture-not actual needs
        \item Direct API calls are faster and clearer
        \item Lower latency and reduced system complexity
        \item Easier to debug, scale, and maintain	
		\item Skip the MCP if your API already works
        \item Avoid unnecessary layers for trend's sake
        \item Prioritize shipping over architecture theater
    \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large MCP is not REST API}

{\tiny (Ref: Lee Han Chun)}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Essence of Good API Design}
\begin{itemize}
  \item Easy to understand: Intent of endpoints should be clear.
  \item Consistent: Follows predictable conventions.
  \item Extensible: Supports versioning and future growth.
  \item Efficient: Minimizes compute and network cost.
  \item API = Contract: Changing it later is hard and costly.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{REST API Primer}
\begin{itemize}
  \item Resource-oriented: Uses HTTP methods to act on data.
  \item CRUD model: Create, Read, Update, Delete.
  \item Self-documenting structure enhances clarity.
  \item Ideal for Human-Computer Interfaces (HCI).
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Example REST Endpoints}
\begin{lstlisting}
GET /api/blogs           // List blogs
GET /api/blogs/{id}      // Get blog
POST /api/blogs          // Create blog
PUT /api/blogs/{id}      // Update blog
DELETE /api/blogs/{id}   // Delete blog
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{MCP: Origins and Design}
\begin{itemize}
  \item Inspired by Language Server Protocol (LSP).
  \item Based on JSON-RPC v2 for inter-process comms.
  \item Designed for LLM agents, not humans.
  \item MCP servers = Plugins for agentic environments.
\end{itemize}

	\begin{center}
	\includegraphics[width=\linewidth,keepaspectratio]{rag39}

	{\tiny (Ref: MCP is not REST API -Lee Han Chun)}
	\end{center}
		
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{RPC APIs: Action-Oriented Design}
\begin{itemize}
  \item RPC treats API as function calls.
  \item Action > Resource: e.g., createUser, getBlog.
  \item Avoids REST’s fixed verbs; uses custom method names.
  \item Protobuf/gRPC and JSON-RPC are popular formats.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{gRPC Example}
\begin{lstlisting}
// blog.proto
service BlogService {
  rpc GetBlog(GetBlogRequest) returns (Blog);
  rpc CreateBlog(CreateBlogRequest) returns (Blog);
}
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Calling gRPC in Python}
\begin{lstlisting}
stub = blog_pb2_grpc.BlogServiceStub(channel)
resp = stub.GetBlog(blog_pb2.GetBlogRequest(blog_id=123))
\end{lstlisting}
\begin{itemize}
  \item Looks like local function calls.
  \item No manual HTTP construction needed.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why Wrapping REST with MCP is Bad}
\begin{itemize}
  \item MCP = Action-oriented; REST = Resource-oriented.
  \item Wrapping REST breaks agent's mental model.
  \item Leads to unclear, inefficient tool usage.
  \item Results in brittle tools and complex workflows.
\end{itemize}

	\begin{center}
	\includegraphics[width=0.6\linewidth,keepaspectratio]{rag40}

	{\tiny (Ref: MCP is not REST API -Lee Han Chun)}
	\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Lost Semantics \& Agent Complexity}
\begin{itemize}
  \item Agents prefer high-level verbs (e.g. archiveOldBlogPosts).
  \item REST forces agents to sequence CRUD ops.
  \item Tools lose expressive power and clarity.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Transactionality Issues}
\begin{itemize}
  \item REST is stateless: no built-in transaction support.
  \item MCP can encapsulate entire logic in one RPC.
  \item Example: transferBlogPostOwnership should be atomic.
  \item REST wrapper introduces risk of inconsistent state.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Efficiency & Tool Brittleness}
\begin{itemize}
  \item Wrappers require multiple REST calls for small tasks.
  \item Example: incrementLikeCount requires GET + PUT.
  \item REST-based MCPs are fragile to backend changes.
  \item RPC APIs are stable, goal-aligned contracts.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Design APIs for Actions, Not Data}
\begin{itemize}
  \item REST = Data manipulation, not goal execution.
  \item MCP tools should reflect agent capabilities.
  \item Wrapping REST limits agent reliability and power.
  \item Design dedicated RPCs aligned with agent tasks.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Conclusion}
\begin{itemize}
  \item REST is great for CRUD and human interfaces.
  \item MCP/RPC is built for agent action and autonomy.
  \item Wrapping REST with MCP leads to poor agent UX.
  \item Use RPC-first APIs for effective Agent-Computer Interaction.
\end{itemize}
\end{frame}

\end{document}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{}
% \begin{center}
% {\Large Zerodha Kite MCP Server}
% \end{center}
% \end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{References}
    \begin{itemize}
        \item What Are MCP Servers? (And How I Built an AI Trading Bot on It) - Harkirat Singh
    \end{itemize}
\end{frame}



