%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large What's New in LangChain Ecosystem}

{\tiny (Oct 2025, Release of 1.0 version)}

\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Major Additions in LangChain/Graph 1.0}
  \begin{itemize}
    \item LangChain is now on top of LangGraph (not the other way round, as before)
	\item LangChain agent \lstinline|create_agent| (ReACT) is one specialized case of many types in LangGraph. You can even visualize it as a workflow of nodes.
	\item Middle-ware to control the data before going to LLM. Curation, sumamrization, context engineering, etc.
	\item Standard content blocks to cater to different output formats by different LLMs.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Code Reorganization  in LangChain/Graph 1.0}
This is in line with principle of 'Simplified Name-spaces'.

  \begin{itemize}
    \item LangChain legacy chains, hub, vector stores, retrievers etc are now part of \lstinline|langchain_classic| module. 
	\item All agents are in \lstinline|langchain.agents|
	\item All Models are in \lstinline|langchain.chat_models|
	\item All Tools are in \lstinline|langchain.tools|
	\item All Messages are in \lstinline|langchain.messages|	
	\item All Embeddings are in \lstinline|langchain.embeddings|	
	
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{LangChain v1: What's New}

\textbf{Major Changes in v1.0 (October 2025):}

\begin{itemize}
\item \textbf{Simplified Package Structure}:
    \begin{itemize}
    \item Core functionality in \texttt{langchain}
    \item Legacy features moved to \texttt{langchain-classic}
    \item Requires Python 3.10+ (Python 3.9 EOL October 2025)
    \end{itemize}

\item \textbf{Agent-First Design}:
    \begin{itemize}
    \item New \texttt{create\_agent()} function
    \item Built on LangGraph runtime
    \item Durable execution and persistence
    \end{itemize}

\item \textbf{Content Blocks}:
    \begin{itemize}
    \item Standardized message format across providers
    \item Support for text, images, reasoning, tool calls
    \item Better multimodal support
    \end{itemize}

\item \textbf{Middleware System}:
    \begin{itemize}
    \item Inject custom logic at any point
    \item Human-in-the-loop support
    \item Error handling and retries
    \end{itemize}
\end{itemize}

{\tiny (Ref: LangChain v1.0 Release Notes)}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{How LangChain 1.0 Simplifies Agents to Just 10 Lines of Code}
  \begin{itemize}
    \item LangChain 1.0 Alpha released; full 1.0 expected by late October.
    \item Rewritten as a simplified agent runtime built on LangGraph.
    \item Agents can now be created in roughly 10/few lines of code.
    \item Legacy LangChain moved to “LangChain Classic.”
    \item Functionally similar to OpenAI or Pedantic SDK agents.
    \item Unified “create\_agent” abstraction across languages.
    \item Integrates easily with external SDKs like Google’s 80k.
  \end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why LangGraph 1.0 is Nearly Non-Breaking and Production-Ready}
  \begin{itemize}
    \item LangGraph 1.0 introduces minimal breaking changes from prior releases.
    \item Existing LangGraph implementations continue to work as-is.
    \item Core runtime stable across Python and TypeScript.
    \item Supports durable execution with checkpoints and rollback.
    \item State can persist via Postgres or SQLite for reliability.
    \item Human-in-the-loop and interrupt handling built-in.
    \item Ready for production-grade use; used by Uber, LinkedIn, Klarna, JPMorgan, Cloudflare.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{The New Standardized Content Blocks for Easier Model Switching}
  \begin{itemize}
    \item LangChain Core now uses standardized content/message blocks.
    \item Abstracts input/output across providers like OpenAI and Anthropic.
    \item Simplifies switching models without rewriting logic.
    \item Unifies multimodal inputs, reasoning traces, and tool calls.
    \item Middleware layer ensures consistent formatting and metadata.
    \item Supports normalized logging across different model providers.
    \item Key enabler for multi-model experimentation and portability.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Durable Execution, Streaming, Human-in-the-Loop, and Time Travel}
  \begin{itemize}
    \item Agents persist state with rollback and checkpointing.
    \item Supports human approval and manual intervention mid-run.
    \item Time travel enables returning to earlier workflow states.
    \item Four streaming modes: messages, updates, values, custom.
    \item Update streaming ideal for dashboards and UX refresh.
    \item State persistence possible locally or via Postgres.
    \item Enables retry and branch execution for debugging and auditing.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large What's New in LangChain Ecosystem}

{\tiny (Oct 2025, Release of 1.0 version)}

\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{1. LangChain Agents: The Standard Loop}
\begin{itemize}
    \item \textbf{High-Level Abstraction:} Simplest and fastest way to build an agent.
    \item \textbf{Primary Pattern:} Implements the standard \textbf{ReAct-style loop} (Reasoning + Acting).
	    \item \textbf{Key Feature}: The \lstinline|create_agent| function (introduced in v1.0) is the simplest and fastest way to build a production-ready agent. It abstracts away the complexity.
    \item \textbf{Process:} The LLM decides at each step whether to use a tool or provide a final answer.
    \item \textbf{Underlying Technology:} LangChain's agents since v1.0 are built \textbf{on top of the LangGraph runtime}.
    \item \textbf{Use Case:} Quick start, simple linear tasks, default agent behavior.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{2. LangGraph: Workflow Automation \& Control}
\begin{itemize}
    \item \textbf{Role:} Low-level \textbf{orchestration framework} and runtime.
    \item \textbf{Core Feature:} Defines explicit workflow automation and agent orchestration. Complex, stateful, and cyclic workflows as directed graphs.
    \item \textbf{Structure:} You define:
    \begin{enumerate}
        \item \textbf{Nodes:} Steps (LLM call, tool execution, custom function).
        \item \textbf{Edges:} Conditional logic for transitions (e.g., if tool succeeds, go to Node B; if it fails, go to Node C).
    \end{enumerate}
    \item \textbf{Multi-Agent Systems:} Provides the explicit control needed for building supervised multi-agent systems and defining handoffs.
    \item \textbf{Relationship to LangChain:} Used when the standard LangChain agent loop is insufficient, requiring \textbf{fine-grained control} over the flow.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{3. Deep Agents: Concept for Complex Tasks}
\begin{itemize}
    \item \textbf{Concept/Library:} Not a separate module, but an architectural pattern built on LangGraph for solving highly complex, long-running tasks.
    \item \textbf{Focus:} Advanced context management and planning.
    \item \textbf{Key Techniques:}
    \begin{enumerate}
        \item \textbf{Planning/Decomposition:} Breaking down the goal (e.g., using a "Todo List" tool).
        \item \textbf{Sub-agents:} Delegating specialized tasks to other agents for parallel or sequential execution.
        \item \textbf{Long-Term Memory:} Utilizing external memory or file systems for persistent context.
    \end{enumerate}
    \item \textbf{Underlying Runtime}: Deep Agents are also built on LangGraph, leveraging its capabilities to manage the complex state and flow of the agent's multi-step plan.	
    % \item \textbf{Summary Equation:}
    % $$\text{Deep Agent} \approx \text{LangGraph} + \text{Advanced Planning/Memory}$$
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Summary: Agent Framework Comparison}

\centering
\begin{table}
\begin{tabular}{| p{1.5cm} | p{2.7cm} | p{2.7cm} | p{2.7cm} |}
\hline
\textbf{Feature} & \textbf{LangChain Agent} & \textbf{LangGraph} & \textbf{Deep Agents (Concept)} \\
\hline
\textbf{Abstraction Level} & High-level API & Low-level/Foundational & High-level (Complex Use Case) \\
\hline
\textbf{Primary Goal} & Quick start, simple agent loop (ReAct) & Explicit flow control, durable runtime & Complex, long-running tasks, planning \\
\hline
\textbf{Core Architecture} & Pre-built ReAct loop & Custom, explicit graph (Nodes \& Edges) & Specialized architecture for planning/sub-agents \\
\hline
\textbf{Multi-Agent} & Can be wrapped as a tool for another agent & \textbf{The foundation} for building custom multi-agent flows & Includes sub-agents for specialized tasks \\
\hline
\textbf{Runtime} & \textbf{Built on LangGraph} & \textbf{The Runtime itself} & \textbf{Built on LangGraph} \\
\hline
\end{tabular}
\end{table}

\vspace{0.2cm}
\textbf{Key Takeaway:} LangGraph provides the underlying runtime and control flow for both simple and complex agent applications.

\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Real-World Use Cases}
  % \begin{itemize}
    % \item Meeting notes enrichment and summarization pipelines.
    % \item Financial EDI approval flows with human-in-loop steps.
    % \item Real-time dashboards using streaming “update” mode.
    % \item Persistent agent state across cloud or local environments.
    % \item Dynamic model selection for efficiency (e.g., switching from Claude to Llama3).
    % \item Internal RAG/Graph-RAG systems leveraging PGVector.
    % \item Used at scale in production by enterprises and startups alike.
  % \end{itemize}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Anti-Patterns to Avoid}
  % \begin{itemize}
    % \item Token-only streaming without structured updates.
    % \item Relying on ephemeral in-memory state, persist externally.
    % \item Single-function “flat” agents instead of structured graphs.
    % \item Provider lock-in design for model and SDK portability.
    % \item Neglecting checkpointing and recovery strategies.
    % \item Ignoring observability, use LangSmith, LangFuse, or OpenTelemetry.
    % \item Skipping standardized content blocks creates fragility.
  % \end{itemize}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{What’s Next: Deep Agents, Observability, and Insights}
  % \begin{itemize}
    % \item “Deep Agents” — reusable text-file–based agent definitions.
    % \item Built primarily on LangGraph (90%) with lightweight extensions.
    % \item Improved monitoring hooks for Datadog, Signoz, and OpenTelemetry.
    % \item Focus on identifying and isolating production failure modes.
    % \item Better observability for latency, retries, and human-in-loop steps.
    % \item Enhanced docs with production templates and unified JS/Python guides.
    % \item Ongoing investment in developer experience and documentation.
  % \end{itemize}
% \end{frame}


