%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large What's New in LangChain Ecosystem}

{\tiny (Oct 2025, Relase of 1.0 version)}

\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Major Additions in LangChain/Graph 1.0}
  \begin{itemize}
    \item LangChain is now on top of LangGraph (not the other way round, as before)
	\item LangChain agent \lstinline|create_agent| (ReACT) is one specialized case of many types in LangGraph. You can even visualize it as a workflow of nodes.
	\item Middle-ware to control the data before going to LLM. Curation, sumamrization, context engineering, etc.
	\item Standard content blocks to cater to different output formats by different LLMs.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Code Reorganization  in LangChain/Graph 1.0}
This is in line with principle of 'Simplified Name-spaces'.

  \begin{itemize}
    \item LangChain legacy chains, hub, vector stores, retrievers etc are now part of \lstinline|langchain_classic| module. 
	\item All agents are in \lstinline|langchain.agents|
	\item All Models are in \lstinline|langchain.chat_models|
	\item All Tools are in \lstinline|langchain.tools|
	\item All Messages are in \lstinline|langchain.messages|	
	\item All Embeddings are in \lstinline|langchain.embeddings|	
	
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{LangChain v1: What's New}

\textbf{Major Changes in v1.0 (October 2025):}

\begin{itemize}
\item \textbf{Simplified Package Structure}:
    \begin{itemize}
    \item Core functionality in \texttt{langchain}
    \item Legacy features moved to \texttt{langchain-classic}
    \item Requires Python 3.10+ (Python 3.9 EOL October 2025)
    \end{itemize}

\item \textbf{Agent-First Design}:
    \begin{itemize}
    \item New \texttt{create\_agent()} function
    \item Built on LangGraph runtime
    \item Durable execution and persistence
    \end{itemize}

\item \textbf{Content Blocks}:
    \begin{itemize}
    \item Standardized message format across providers
    \item Support for text, images, reasoning, tool calls
    \item Better multimodal support
    \end{itemize}

\item \textbf{Middleware System}:
    \begin{itemize}
    \item Inject custom logic at any point
    \item Human-in-the-loop support
    \item Error handling and retries
    \end{itemize}
\end{itemize}

{\tiny (Ref: LangChain v1.0 Release Notes)}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{How LangChain 1.0 Simplifies Agents to Just 10 Lines of Code}
  \begin{itemize}
    \item LangChain 1.0 Alpha released; full 1.0 expected by late October.
    \item Rewritten as a simplified agent runtime built on LangGraph.
    \item Agents can now be created in roughly 10/few lines of code.
    \item Legacy LangChain moved to “LangChain Classic.”
    \item Functionally similar to OpenAI or Pedantic SDK agents.
    \item Unified “create\_agent” abstraction across languages.
    \item Integrates easily with external SDKs like Google’s 80k.
  \end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why LangGraph 1.0 is Nearly Non-Breaking and Production-Ready}
  \begin{itemize}
    \item LangGraph 1.0 introduces minimal breaking changes from prior releases.
    \item Existing LangGraph implementations continue to work as-is.
    \item Core runtime stable across Python and TypeScript.
    \item Supports durable execution with checkpoints and rollback.
    \item State can persist via Postgres or SQLite for reliability.
    \item Human-in-the-loop and interrupt handling built-in.
    \item Ready for production-grade use; used by Uber, LinkedIn, Klarna, JPMorgan, Cloudflare.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{The New Standardized Content Blocks for Easier Model Switching}
  \begin{itemize}
    \item LangChain Core now uses standardized content/message blocks.
    \item Abstracts input/output across providers like OpenAI and Anthropic.
    \item Simplifies switching models without rewriting logic.
    \item Unifies multimodal inputs, reasoning traces, and tool calls.
    \item Middleware layer ensures consistent formatting and metadata.
    \item Supports normalized logging across different model providers.
    \item Key enabler for multi-model experimentation and portability.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Durable Execution, Streaming, Human-in-the-Loop, and Time Travel}
  \begin{itemize}
    \item Agents persist state with rollback and checkpointing.
    \item Supports human approval and manual intervention mid-run.
    \item Time travel enables returning to earlier workflow states.
    \item Four streaming modes: messages, updates, values, custom.
    \item Update streaming ideal for dashboards and UX refresh.
    \item State persistence possible locally or via Postgres.
    \item Enables retry and branch execution for debugging and auditing.
  \end{itemize}
\end{frame}



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Real-World Use Cases}
  % \begin{itemize}
    % \item Meeting notes enrichment and summarization pipelines.
    % \item Financial EDI approval flows with human-in-loop steps.
    % \item Real-time dashboards using streaming “update” mode.
    % \item Persistent agent state across cloud or local environments.
    % \item Dynamic model selection for efficiency (e.g., switching from Claude to Llama3).
    % \item Internal RAG/Graph-RAG systems leveraging PGVector.
    % \item Used at scale in production by enterprises and startups alike.
  % \end{itemize}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{Anti-Patterns to Avoid}
  % \begin{itemize}
    % \item Token-only streaming without structured updates.
    % \item Relying on ephemeral in-memory state, persist externally.
    % \item Single-function “flat” agents instead of structured graphs.
    % \item Provider lock-in design for model and SDK portability.
    % \item Neglecting checkpointing and recovery strategies.
    % \item Ignoring observability, use LangSmith, LangFuse, or OpenTelemetry.
    % \item Skipping standardized content blocks creates fragility.
  % \end{itemize}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile]\frametitle{What’s Next: Deep Agents, Observability, and Insights}
  % \begin{itemize}
    % \item “Deep Agents” — reusable text-file–based agent definitions.
    % \item Built primarily on LangGraph (90%) with lightweight extensions.
    % \item Improved monitoring hooks for Datadog, Signoz, and OpenTelemetry.
    % \item Focus on identifying and isolating production failure modes.
    % \item Better observability for latency, retries, and human-in-loop steps.
    % \item Enhanced docs with production templates and unified JS/Python guides.
    % \item Ongoing investment in developer experience and documentation.
  % \end{itemize}
% \end{frame}


