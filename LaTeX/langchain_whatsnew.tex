%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large What's New in LangChain Ecosystem}

{\tiny (Oct 2025, Relase of 1.0 version)}

\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why LangGraph 1.0 is Nearly Non-Breaking and Production-Ready}
  \begin{itemize}
    \item LangGraph 1.0 introduces minimal breaking changes from prior releases.
    \item Existing LangGraph implementations continue to work as-is.
    \item Core runtime stable across Python and TypeScript.
    \item Supports durable execution with checkpoints and rollback.
    \item State can persist via Postgres or SQLite for reliability.
    \item Human-in-the-loop and interrupt handling built-in.
    \item Ready for production-grade use; used by Uber, LinkedIn, Klarna, JPMorgan, Cloudflare.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{How LangChain 1.0 Simplifies Agents to Just 10 Lines of Code}
  \begin{itemize}
    \item LangChain 1.0 Alpha released; full 1.0 expected by late October.
    \item Rewritten as a simplified agent runtime built on LangGraph.
    \item Agents can now be created in roughly 10 lines of code.
    \item Legacy LangChain moved to “LangChain Classic.”
    \item Functionally similar to OpenAI or Pedantic SDK agents.
    \item Unified “create\_agent” abstraction across languages.
    \item Integrates easily with external SDKs like Google’s 80k.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Durable Execution, Streaming, Human-in-the-Loop, and Time Travel}
  \begin{itemize}
    \item Agents persist state with rollback and checkpointing.
    \item Supports human approval and manual intervention mid-run.
    \item Time travel enables returning to earlier workflow states.
    \item Four streaming modes: messages, updates, values, custom.
    \item Update streaming ideal for dashboards and UX refresh.
    \item State persistence possible locally or via Postgres.
    \item Enables retry and branch execution for debugging and auditing.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{The New Standardized Content Blocks for Easier Model Switching}
  \begin{itemize}
    \item LangChain Core now uses standardized content/message blocks.
    \item Abstracts input/output across providers like OpenAI and Anthropic.
    \item Simplifies switching models without rewriting logic.
    \item Unifies multimodal inputs, reasoning traces, and tool calls.
    \item Middleware layer ensures consistent formatting and metadata.
    \item Supports normalized logging across different model providers.
    \item Key enabler for multi-model experimentation and portability.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Real-World Use Cases}
  \begin{itemize}
    \item Meeting notes enrichment and summarization pipelines.
    \item Financial EDI approval flows with human-in-loop steps.
    \item Real-time dashboards using streaming “update” mode.
    \item Persistent agent state across cloud or local environments.
    \item Dynamic model selection for efficiency (e.g., switching from Claude to Llama3).
    \item Internal RAG/Graph-RAG systems leveraging PGVector.
    \item Used at scale in production by enterprises and startups alike.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Example: Defining a Simple Agent in LangChain 1.0}
\begin{lstlisting}[language=Python]
from langchain.agents import create_agent

agent = create_agent(
    tools=[search, summarize],
    model="gpt-4-turbo"
)

result = agent("Summarize today's meeting notes")
print(result)
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Anti-Patterns to Avoid}
  \begin{itemize}
    \item Token-only streaming without structured updates.
    \item Relying on ephemeral in-memory state—persist externally.
    \item Single-function “flat” agents instead of structured graphs.
    \item Provider lock-in—design for model and SDK portability.
    \item Neglecting checkpointing and recovery strategies.
    \item Ignoring observability—use LangSmith, LangFuse, or OpenTelemetry.
    \item Skipping standardized content blocks creates fragility.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{What’s Next: Deep Agents, Observability, and Insights}
  \begin{itemize}
    \item “Deep Agents” — reusable text-file–based agent definitions.
    \item Built primarily on LangGraph (90%) with lightweight extensions.
    \item Improved monitoring hooks for Datadog, Signoz, and OpenTelemetry.
    \item Focus on identifying and isolating production failure modes.
    \item Better observability for latency, retries, and human-in-loop steps.
    \item Enhanced docs with production templates and unified JS/Python guides.
    \item Ongoing investment in developer experience and documentation.
  \end{itemize}
\end{frame}


