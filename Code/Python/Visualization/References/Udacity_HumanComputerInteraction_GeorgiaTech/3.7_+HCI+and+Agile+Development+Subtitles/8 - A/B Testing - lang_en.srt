1
00:00:00,270 --> 00:00:04,760
So in some contexts, it's now no harder
to construct an actual interface than it

2
00:00:04,760 --> 00:00:08,530
is to construct a prototype, so we might
skip the prototyping phase altogether.

3
00:00:08,530 --> 00:00:12,290
However, prototypes also allowed
us to gather feedback from users.

4
00:00:12,290 --> 00:00:14,670
Even though we can now easily
construct an interface,

5
00:00:14,670 --> 00:00:17,878
we don't want to immediately roll out
a completely untested interface to

6
00:00:17,878 --> 00:00:19,610
everyone who visits our site.

7
00:00:19,610 --> 00:00:23,480
We might be able to fix it quickly, but
we're still eroding user trust in us and

8
00:00:23,480 --> 00:00:25,000
wasting our user's time.

9
00:00:25,000 --> 00:00:28,220
That's where the second facet
of this comes in, AB testing.

10
00:00:28,220 --> 00:00:31,700
AB testing is the name given to rapid
software testing between typically two

11
00:00:31,700 --> 00:00:33,330
alternatives, A and B.

12
00:00:33,330 --> 00:00:35,800
Statistically it's not any
different from T-tests.

13
00:00:35,800 --> 00:00:39,570
What makes AB testing unique is that
we're usually rapidly testing small

14
00:00:39,570 --> 00:00:41,460
changes with real users.

15
00:00:41,460 --> 00:00:45,090
We usually do it by rolling out the B
version, the new version to only a small

16
00:00:45,090 --> 00:00:48,120
number of users, and ensuring that
nothing goes terribly wrong, or

17
00:00:48,120 --> 00:00:50,680
there's not a dramatic
dip in performance.

18
00:00:50,680 --> 00:00:53,870
That way we can make sure a change is
positive, or at least neutral, before

19
00:00:53,870 --> 00:00:57,845
rolling it out to everyone, but look
where testing feedback coming in here.

20
00:00:57,845 --> 00:01:00,930
They're coming automatically with
the real users during normal

21
00:01:00,930 --> 00:01:02,290
usage of our tool.

22
00:01:02,290 --> 00:01:04,640
There's no added cost to
recruiting participants and

23
00:01:04,640 --> 00:01:06,680
the feedback is received instantly.

24
00:01:06,680 --> 00:01:09,005
So for a quick example,
this is the overview page for

25
00:01:09,005 --> 00:01:11,870
one of Udacity's programs and it
provides a timeline the students should

26
00:01:11,870 --> 00:01:14,640
dedicate to the program in
terms of number of hours.

27
00:01:14,640 --> 00:01:16,990
Is number of hours the best
way to display this?

28
00:01:16,990 --> 00:01:18,810
I don't know, we could find out.

29
00:01:18,810 --> 00:01:23,290
Instead of showing 420 hours maybe
I say this as 20 hours per week.

30
00:01:23,290 --> 00:01:26,080
In this interface all I
have to do is edit it and

31
00:01:26,080 --> 00:01:29,525
I immediately have a new version of
this interface that I can try out.

32
00:01:29,525 --> 00:01:31,635
Now I can click Start Experiment and
try this out.

33
00:01:31,635 --> 00:01:32,660
I could find out.

34
00:01:32,660 --> 00:01:35,885
Does phrasing this as ten hours per
week, does it increase the number?

35
00:01:35,885 --> 00:01:37,335
Does it decrease the number?

36
00:01:37,335 --> 00:01:39,745
If it decreases it,
I can very quickly roll this back.

37
00:01:39,745 --> 00:01:42,185
If it increases it, I can very
quickly roll this out to everybody.

38
00:01:42,185 --> 00:01:44,505
I'm going through the same
design life cycle.

39
00:01:44,505 --> 00:01:47,365
I understand that the need is for
the user to know where the timeline is.

40
00:01:47,365 --> 00:01:48,355
I've got a design in mind,

41
00:01:48,355 --> 00:01:50,945
which is to show the timeline
in number of hours per week.

42
00:01:50,945 --> 00:01:51,875
I prototype it.

43
00:01:51,875 --> 00:01:54,020
It just happens to be here
that the prototype is live.

44
00:01:54,020 --> 00:01:55,490
And I immediately roll it out.

45
00:01:55,490 --> 00:01:57,680
I look at how users use it,
I evaluate it, and

46
00:01:57,680 --> 00:02:00,720
I decide if I want to roll back that
change, or roll it out to everybody.

47
00:02:00,720 --> 00:02:03,388
I can go through a microcosm, a very
rapid iteration to really design life

48
00:02:03,388 --> 00:02:06,540
cycle by using live prototyping and
AB testing.

