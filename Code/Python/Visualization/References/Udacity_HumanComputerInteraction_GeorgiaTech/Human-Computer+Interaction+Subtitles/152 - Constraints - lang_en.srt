1
00:00:00,000 --> 00:00:01,814
In designing user interfaces,

2
00:00:01,814 --> 00:00:04,815
our goal is typically to make the interface usable,

3
00:00:04,815 --> 00:00:08,265
and a big part of usability is accounting for user error.

4
00:00:08,265 --> 00:00:11,910
Many design theorists argue that there's actually no such thing as user error.

5
00:00:11,910 --> 00:00:13,500
If the user commits an error,

6
00:00:13,500 --> 00:00:17,475
it was because the system was not structured in a way to prevent or recover from it,

7
00:00:17,475 --> 00:00:19,485
and I happen to agree with that.

8
00:00:19,485 --> 00:00:21,870
Now, one way we can avoid error is by

9
00:00:21,870 --> 00:00:25,005
preventing the user from performing erroneously in the first place.

10
00:00:25,005 --> 00:00:27,285
This is the idea of constraints.

11
00:00:27,285 --> 00:00:31,470
Constraining the user to only perform the correct actions in the first place.

12
00:00:31,470 --> 00:00:34,020
On constraints, Norman writes that constraints are

13
00:00:34,020 --> 00:00:37,530
powerful clues limiting the set of possible actions.

14
00:00:37,530 --> 00:00:40,140
The thoughtful use of constraints in design lets people

15
00:00:40,140 --> 00:00:42,690
readily determine the proper course of action,

16
00:00:42,690 --> 00:00:45,075
even in a novel situation.

17
00:00:45,075 --> 00:00:48,410
Remember, designing so that users are immediately comfortable in

18
00:00:48,410 --> 00:00:52,270
novel situations is one of the goals of good user interface design.

19
00:00:52,270 --> 00:00:56,000
Nielsen notes that even better than good error messages is

20
00:00:56,000 --> 00:00:59,630
a careful design which prevents a problem from occurring in the first place.

21
00:00:59,630 --> 00:01:02,900
Either eliminate error-prone conditions or check for them and

22
00:01:02,900 --> 00:01:06,355
present users with a confirmation option before they commit to the action.

23
00:01:06,355 --> 00:01:08,750
For example, if our application was prone to

24
00:01:08,750 --> 00:01:11,689
users accidentally closing it when they don't mean to,

25
00:01:11,689 --> 00:01:14,815
ask them when it's about to close if that's actually what they meant to do.

26
00:01:14,815 --> 00:01:17,410
Both of these approaches refer to the need to

27
00:01:17,410 --> 00:01:20,610
stop faulty user input before it's even received.

28
00:01:20,610 --> 00:01:23,530
This is a principle you might already encountered a lot.

29
00:01:23,530 --> 00:01:26,125
Our password reset screen actually does this pretty well.

30
00:01:26,125 --> 00:01:29,440
First, it shows us the constraints under which we're operating right there

31
00:01:29,440 --> 00:01:33,320
visibly on the screen so we're not left guessing as to what we're supposed to be doing.

32
00:01:33,320 --> 00:01:35,000
Then as we start to interact,

33
00:01:35,000 --> 00:01:37,420
it tells us if we're violating any of those constraints.

34
00:01:37,420 --> 00:01:42,400
So, if I were to just try to make my password the incredibly common 1234,

35
00:01:42,400 --> 00:01:45,010
it immediately tells me that my password isn't long

36
00:01:45,010 --> 00:01:48,020
enough and it doesn't represent enough character classes.

37
00:01:48,020 --> 00:01:51,730
Now, obviously, it can't prevent me from entering 1234 in the first place,

38
00:01:51,730 --> 00:01:55,235
since maybe that's along the way to a longer more valid password.

39
00:01:55,235 --> 00:01:58,900
But it's visualizing those constraints so that instead of submitting and

40
00:01:58,900 --> 00:02:00,610
getting frustrated when it didn't tell me I

41
00:02:00,610 --> 00:02:02,680
was doing it wrong until I'd actually done it,

42
00:02:02,680 --> 00:02:06,275
it actually tells me right in the context of doing it I'm not on the right track.

43
00:02:06,275 --> 00:02:08,030
This is kind of a soft constraint.

44
00:02:08,030 --> 00:02:09,870
It doesn't prevent me from doing something,

45
00:02:09,870 --> 00:02:12,570
but it tells me while I'm doing it that I'm doing it wrong.

46
00:02:12,570 --> 00:02:15,650
A harder constraint goes along with that last bullet: can

47
00:02:15,650 --> 00:02:18,740
only contain characters printed on the computer's keyboard.

48
00:02:18,740 --> 00:02:22,640
Right now, I'm trying to paste in a character that isn't on the computer keyboard,

49
00:02:22,640 --> 00:02:24,500
and it's just not showing it all together.

50
00:02:24,500 --> 00:02:27,710
It's a hard constraint against the inputting characters that aren't allowed.

51
00:02:27,710 --> 00:02:32,035
So, it's preventing me from putting an invalid input in the first place.

52
00:02:32,035 --> 00:02:33,670
So, in their simplest form,

53
00:02:33,670 --> 00:02:35,900
constraints can be described as preventing the user

54
00:02:35,900 --> 00:02:39,170
from putting an input that wasn't going to work anyway.

