1
00:00:00,000 --> 00:00:03,825
There are strengths and weaknesses to the GOMS representation for tasks.

2
00:00:03,825 --> 00:00:05,850
One weakness is that it doesn't automatically

3
00:00:05,850 --> 00:00:08,460
address a lot of the complexity of these problems.

4
00:00:08,460 --> 00:00:10,860
For example, there are likely many different methods

5
00:00:10,860 --> 00:00:12,885
and submethods for addressing this goal.

6
00:00:12,885 --> 00:00:15,900
Before even getting this selection rules among what route to take,

7
00:00:15,900 --> 00:00:17,010
you might decide whether to take

8
00:00:17,010 --> 00:00:19,520
public transportation or whether to work from home that day.

9
00:00:19,520 --> 00:00:20,915
In parallel to that,

10
00:00:20,915 --> 00:00:22,700
even after deciding to drive,

11
00:00:22,700 --> 00:00:25,825
you might decide what car to take if your family has more than one car.

12
00:00:25,825 --> 00:00:28,495
The standard GOMS model leaves those kind of things out,

13
00:00:28,495 --> 00:00:30,440
although there are augmented versions that have been

14
00:00:30,440 --> 00:00:32,390
created to deal with this kind of complexity

15
00:00:32,390 --> 00:00:36,785
like CMN GOMS or in GOMS L. We'll talk about those a bit more later.

16
00:00:36,785 --> 00:00:39,500
A second weakness is that the GOMS model assumes

17
00:00:39,500 --> 00:00:42,140
the user already has these methods in mind,

18
00:00:42,140 --> 00:00:44,735
that means the user is already an expert in the area.

19
00:00:44,735 --> 00:00:49,450
GOMS models don't do a good job of accounting for novices or accounting for user errors.

20
00:00:49,450 --> 00:00:52,400
For example, if you are driving in an unfamiliar location,

21
00:00:52,400 --> 00:00:54,030
you don't even know what the methods are,

22
00:00:54,030 --> 00:00:55,910
let alone how to choose among them.

23
00:00:55,910 --> 00:00:59,330
The strength of GOMS models on the other hand is their ability to

24
00:00:59,330 --> 00:01:03,940
formalize user interaction into steps that we can use to actually make predictions.

25
00:01:03,940 --> 00:01:07,310
We can measure how long each these operators takes and so we

26
00:01:07,310 --> 00:01:10,870
can predict the overall efficiency of using a certain interface.

27
00:01:10,870 --> 00:01:13,430
For example, in this GOMS model if we had included

28
00:01:13,430 --> 00:01:16,340
the operator to pull keys out of the users pocket,

29
00:01:16,340 --> 00:01:19,250
we might quickly identify that the relative efficiency of

30
00:01:19,250 --> 00:01:23,405
these two methods is very much dependent on how long that step takes.

31
00:01:23,405 --> 00:01:25,595
The Key Chain method might be a lot faster

32
00:01:25,595 --> 00:01:28,040
if the user can get their key chain out pretty quickly.

33
00:01:28,040 --> 00:01:29,240
But for other users,

34
00:01:29,240 --> 00:01:30,740
the fact that they need to pull something out of

35
00:01:30,740 --> 00:01:33,110
their pocket while holding bags or holding a baby,

36
00:01:33,110 --> 00:01:35,440
makes a keypad a more efficient option.

37
00:01:35,440 --> 00:01:37,255
By performing that kind of reasoning,

38
00:01:37,255 --> 00:01:41,950
we can focus on areas that either method and the interface as a whole can be improved.

