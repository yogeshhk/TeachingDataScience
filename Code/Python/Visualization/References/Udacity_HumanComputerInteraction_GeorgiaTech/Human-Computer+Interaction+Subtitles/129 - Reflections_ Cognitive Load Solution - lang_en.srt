1
00:00:00,280 --> 00:00:03,570
Computer programming is one task with
an incredibly high cognitive load.

2
00:00:03,570 --> 00:00:07,090
At any given time, you're likely holding
in working memory your goals for

3
00:00:07,090 --> 00:00:10,210
this line of code, your goals for this
function, your goals for this portion of

4
00:00:10,210 --> 00:00:14,030
the program as a whole, the variables
you've created and a lot more.

5
00:00:14,030 --> 00:00:16,830
That's why there's so many jokes about
how bad it is to interrupt a programmer,

6
00:00:16,830 --> 00:00:17,430
because they have so

7
00:00:17,430 --> 00:00:20,730
much in working memory that they lose
when they transition to another task.

8
00:00:20,730 --> 00:00:24,190
But there are ways good IDEs
can help mitigate those issues.

9
00:00:24,190 --> 00:00:27,660
For example, inline automated error
checking is one way to reduce

10
00:00:27,660 --> 00:00:30,500
the cognitive load on programmers,
because it lets them focus more on

11
00:00:30,500 --> 00:00:34,320
what they're trying to accomplish rather
than the low level syntax mistakes.

12
00:00:34,320 --> 00:00:37,790
In that way, the IDE offloads some
of the responsibility from the user

13
00:00:37,790 --> 00:00:38,310
to the interface.

14
00:00:38,310 --> 00:00:40,559
Now we could phrase that
a little bit differently too.

15
00:00:40,559 --> 00:00:44,286
We could describe this as distributing
the cognitive load more evenly between

16
00:00:44,286 --> 00:00:47,690
the different components of the system,
myself and the computer.

17
00:00:47,690 --> 00:00:51,050
That's a perspective we discuss when
we talk about distributed cognition.

