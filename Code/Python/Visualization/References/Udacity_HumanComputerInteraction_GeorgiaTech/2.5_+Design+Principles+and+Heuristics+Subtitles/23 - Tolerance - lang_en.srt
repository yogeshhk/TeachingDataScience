1
00:00:00,000 --> 00:00:03,360
We can't constrain away all errors all the time though.

2
00:00:03,360 --> 00:00:05,910
So, there are two principles for how we deal with

3
00:00:05,910 --> 00:00:09,255
errors that do occur, feedback and tolerance.

4
00:00:09,255 --> 00:00:14,010
Tolerance means that users shouldn't be at risk of causing too much trouble accidentally.

5
00:00:14,010 --> 00:00:15,760
For this Nielsen writes that,

6
00:00:15,760 --> 00:00:18,210
"Users often choose system functions by mistake,

7
00:00:18,210 --> 00:00:20,910
and will need a clearly marked 'emergency exit' to

8
00:00:20,910 --> 00:00:24,165
leave the unwanted state without having to go through an extended dialogue.

9
00:00:24,165 --> 00:00:26,475
Support, undo and redo."

10
00:00:26,475 --> 00:00:27,885
For Constantine and Lockwood,

11
00:00:27,885 --> 00:00:29,505
this is the tolerance principle.

12
00:00:29,505 --> 00:00:31,980
They write, "The design should be flexible and tolerant,

13
00:00:31,980 --> 00:00:36,480
reducing the cost of mistakes and misuse by allowing undoing and redoing,

14
00:00:36,480 --> 00:00:38,735
while also preventing errors wherever possible."

15
00:00:38,735 --> 00:00:40,160
It should be becoming clear why

16
00:00:40,160 --> 00:00:43,325
that Control-Y issue with Visual Studio was so significant.

17
00:00:43,325 --> 00:00:46,685
Undo and redo are fundamental concepts of tolerance,

18
00:00:46,685 --> 00:00:49,640
and that Control-Y issue where Control-Y removes the line in

19
00:00:49,640 --> 00:00:54,550
Visual Studio gets in the way of redo allowing us to recover from mistakes.

20
00:00:54,550 --> 00:00:58,065
For Dix et al., this is the principle of recoverability.

21
00:00:58,065 --> 00:01:02,510
Now, Nielsen's definition is most interested in supporting user experimentation.

22
00:01:02,510 --> 00:01:05,605
The system should tolerate users poking around with things.

23
00:01:05,605 --> 00:01:07,200
Universal design simply says,

24
00:01:07,200 --> 00:01:08,870
"The design minimizes hazards and

25
00:01:08,870 --> 00:01:12,490
the adverse consequences of accidental or unintended actions."

26
00:01:12,490 --> 00:01:16,195
Dix et al. also refers to this as the principle of recoverability.

27
00:01:16,195 --> 00:01:20,720
Now, Nielsen's definition is most interested in supporting user experimentation.

28
00:01:20,720 --> 00:01:23,720
The system should tolerate users poking around with things.

29
00:01:23,720 --> 00:01:26,885
That actually enhances the principle of discoverability.

30
00:01:26,885 --> 00:01:29,720
Because if the user feels safe experimenting with things,

31
00:01:29,720 --> 00:01:32,090
they're more likely to discover what's available to them.

32
00:01:32,090 --> 00:01:34,190
The principles from Constantine and Lockwood,

33
00:01:34,190 --> 00:01:36,590
and the principles of universal design are more

34
00:01:36,590 --> 00:01:39,215
about recovering from traditional mistakes.

35
00:01:39,215 --> 00:01:43,020
Jef Raskin poses this as a more humorous law of interface design,

36
00:01:43,020 --> 00:01:46,325
"A computer shall not harm your work or through inactivity,

37
00:01:46,325 --> 00:01:48,370
allow your work to come to harm."

38
00:01:48,370 --> 00:01:50,360
So, we first have to make sure that the system

39
00:01:50,360 --> 00:01:53,164
prevents the user from doing too much damage accidentally.

40
00:01:53,164 --> 00:01:56,270
Either by constraining them away from making those mistakes,

41
00:01:56,270 --> 00:01:59,890
or allowing an easy way to recover once those mistakes have been made.

