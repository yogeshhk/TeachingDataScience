\input{../shared/shared}

\renewcommand{\course}{Robotics}
\renewcommand{\coursepicture}{roboticsLecture}
\renewcommand{\coursedate}{Winter 2014}
\renewcommand{\topic}{Kinematics}

\slides

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Mobile robotics vs. Manipulation vs. Kinematic/Dynamic motion control}
\slide{}{

\item Two ``types of robotics'':

1) Mobile robotics ~ -- ~ is all about localization \& mapping

2) Manipulation ~ -- ~ is all about interacting with the world

0) Kinematic/Dynamic Motion Control: same as 2) without ever making it
to interaction..

~

\item Typical manipulation robots (and animals) are kinematic trees

Their pose/state is described by all joint angles

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Basic motion generation problem}{

\item Move all joints in a coordinated way so that the endeffector
makes a desired movement

~

\show[.4]{multiTask}

\hfill\tiny\texttt{01-kinematics: ./x.exe -mode 2/3/4}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Outline}{

~

\item Basic 3D geometry and notation

~

\item Kinematics:~ $\phi:~ q \mapsto y$

\item Inverse Kinematics:~ $y^* \mapsto q^* = \argmin_q \norm{\phi(q) - y^*}^2_C + \norm{q-q_0}^2_W$

\item Basic motion heuristics:~ Motion profiles

~

\item Additional things to know
\begin{items}
\item Many simultaneous task variables
\item Singularities, null space, 
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sublecture{Basic 3D geometry \& notation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Pose (position \& orientation)}{

\shows[.5]{geo-3D-3}

\item A \emph{pose} is described by a translation $p\in\RRR^3$ and a rotation $R\in SO(3)$
\begin{items}
\item $R$ is an \emph{orthonormal} matrix (orthogonal vectors stay orthogonal, unit vectors stay unit)
\item $R^\1 = R^\T$
\item columns and rows are orthogonal unit vectors
\item $\det(R) = 1$
\item $
R = \mat{ccc}{
  R_{11} & R_{12} & R_{13} \\
  R_{21} & R_{22} & R_{23} \\
  R_{31} & R_{32} & R_{33}}
$
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \slide{Rotation matrix: examples}{

%% \item 3D:
%% \begin{align*}
%% R_z(\t) &= \mat{ccc}{ \cos\t & -\sin\t & 0 \\  \sin\t & \cos\t & 0 \\ 0 & 0 & 1} \\
%% R_y(\t) &= \mat{ccc}{ \cos\t & 0 &  \sin\t \\ 0 & 1 & 0 \\ -\sin\t & 0 & \cos\t} \\
%% R_x(\t) &= \mat{ccc}{ 1 & 0 & 0 \\ 0 & \cos\t & -\sin\t \\ 0 &  \sin\t & \cos\t}
%% \end{align*}


%% \item $\RRR^{3 \times 3}$ has 9 numbers

%% \item 6 constraints ~ (3 orthogonal, 3 normal)

%% \item 3 DoF

%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Coordinate frames and transforms}
\slide{Frame and coordinate transforms}{

\shows[.5]{geo-3D-4}

\item Let $(\vec o,\vec e_{1:3})$ be the world frame, $(\vec o',\vec e'_{1:3})$ be the body's frame.

The new basis vectors are the \emph{columns} in $R$, that is, $\vec
e_1' = R_{11} \vec e_1 + R_{21} \vec e_2 + R_{31} \vec e_3$, etc,


\item
$x$ = coordinates in world frame $(\vec o,\vec e_{1:3})$

$x'$ = coordinates in body frame $(\vec o',\vec e'_{1:3})$

$p$ = coordinates of $\vec o'$ in world frame $(\vec o,\vec e_{1:3})$
$$x = p + R x'$$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Briefly: Alternative Rotation Representations}{

~

(See the ``geometry notes'' for more details!)

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Euler angles}{

\item Describe rotation by consecutive rotation about different axis:
\begin{items}
\item 3-1-3 or 3-1-2 conventions, yaw-pitch-roll (3-2-1) in air flight
\item first rotate $\p$ about $\vec e_3$, then $\t$ about the {new}
  $\vec e_1'$, then $\psi$ about the {new} $\vec e_3''$
\end{items}

\item Gimbal Lock

\show[.3]{gimbal}

\item Euler angles have severe problem:
\begin{items}
\item if two axes align: blocks 1 DoF of rotation!!
\item ``singularity'' of Euler angles
\item Example: 3-1-3 and second rotation 0 or $\pi$
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Rotation vector}{

\item vector $w \in \RRR^3$
\begin{items}
\item length $|w|=\theta$  is rotation angle (in radians)
\item direction of $w$ = rotation axis ($\ubar w=w/\t$)
\end{items}

\item Application on a vector $v$ (Rodrigues' formula):
\begin{align*}
w \cdot v
  = \cos\t~ v
  + \sin\t~ (\ubar w\times v)
  + (1-\cos\t)~ \ubar w(\ubar w^\T v)
\end{align*}

\item Conversion to matrix:
\begin{align*}
R(w)
 &= \exp(\hat w) \\
 &= \cos\t~ I + \sin\t~ \hat w/\t + (1-\cos\t)~ w w^\T/\t^2 \\
\hat w &:= \mat{ccc}{0 & -w_3 & w_2 \\ w_3 & 0 & -w_1 \\-w_2 & w_1 & 0}
\end{align*}
($\hat w$ is called skew matrix, with property $\hat w v = w \times
v$; $\exp(\cdot)$ is called exponential map)

\item Composition: convert to matrix first

\item Drawback: singularity for small rotations

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Quaternion}{

\item A quaternion is $r\in\RRR^4$ with unit length $|r| = r_0^2 +
r_1^2 + r_2^2 + r_3^2 = 1$
\begin{align*}
r &=
% \mat{c}{r_0 \\ r_1 \\ r_2 \\ r_3} =
\mat{c}{r_0 \\ \bar r} \comma
r_0 =\cos(\t/2) \comma
\bar r = \sin(\t/2)~ \ubar w
\end{align*}
where $\ubar w$ is the unit length rotation axis

{\tiny
\item Conversion to matrix
 \begin{align*}
R(r)
 &= \mat{ccc}{
    1-r_{22}-r_{33} & r_{12}-r_{03} &    r_{13}+r_{02} \\
    r_{12}+r_{03} &   1-r_{11}-r_{33} &  r_{23}-r_{01} \\
    r_{13}-r_{02} &   r_{23}+r_{01} &    1-r_{11}-r_{22}
    } \\
r_{ij} &= 2 r_i r_j \comma
    r_0 = \half\sqrt{1+\tr R}\\
    r_3 &= (R_{21}-R_{12})/(4 r_0)\comma
    r_2 = (R_{13}-R_{31})/(4 r_0)\comma
    r_1 = (R_{32}-R_{23})/(4 r_0)
\end{align*}

\item Composition
\begin{align*}
r \circ r'
 = \mat{c}{ r_0 r'_0 - \bar r^\T \bar r' \\
    r_0 \bar r' + r'_0 \bar r + \bar r' \times \bar r }
\end{align*}

\item Application to vector $v$: convert to matrix first

}

\item Benefits: fast composition. No $\sin$/$\cos$
computations. \textbf{Use this!}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \slide{Quaternion}{

%% \begin{tabular}{p{.35\columnwidth}@{\qquad\qquad}p{.35\columnwidth}}
%% pros & cons\\
%% \hline
%% no singularity & somewhat confusing \\
%% almost minimal representation & not quite minimal \\
%% easy to enforce constraint & must convert to matrix to rotate a vector\\
%% easy composition & \\
%% easy interpolation &
%% \end{tabular}

%% }

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{Summary of rotation representations}{

%% \item need rotation matrix to rotate vectors

%% \item Quaternions good for free rotations

%% \item Euler angles ok for small angular deviations (but beware
%%   singularities!)

%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\key{Homogeneous transformation}
\slide{Homogeneous transformations}{

\item $x^A$ = coordinates of a point in frame $A$

$x^B$ = coordinates of a point in frame $B$

~

\item Translation and rotation: ~ $x^A = t + R x^B$

~

\item Homogeneous transform $T\in\RRR^{4\times 4}$:
\begin{align*}
&\TR{A}{B} = \mat{cc}{R & t \\ 0 & 1} \\
&x^A
 = \TR{A}{B}~ x^B
 = \mat{cc}{R & t \\ 0 & 1}~ \mat{c}{x^B \\ 1}
 = \mat{c}{R x^B + t \\ 1}
\end{align*}

\emph{in homogeneous coordinates, we append a 1 to all coordinate vectors}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Is \protect{$\TR{A}{B}$} forward or backward?}{

\item $\TR{A}{B}$ describes the translation and rotation of
\emph{frame} $B$ relative to $A$

That is, it describes the forward FRAME transformation (from
$A$ to $B$)

~

\item $\TR{A}{B}$ describes the coordinate transformation from $x^B$
to $x^A$

That is, it describes the backward COORDINATE transformation

~

\item Confused? Vectors (and frames) transform \emph{covariant},
coordinates \emph{contra-variant}. See ``geometry notes'' or Wikipedia
for more details, if you like.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Composition of transforms}
\slide{Composition of transforms}{

\shows[.5]{geo-transforms-2}
\begin{align*}
\TR{W}{C}
 &= \TR{W}{A}~ \TR{A}{B}~ \TR{B}{C} \\
x^W
 &= \TR{W}{A}~ \TR{A}{B}~ \TR{B}{C}~ x^C
\end{align*}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sublecture{Kinematics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{Notation}{

%% \begin{tabular}{p{.3\columnwidth}p{.7\columnwidth}}
%% $q \in \RRR^n$ & vector of joint angles (robot configuration) \\
%% $\dot q \in \RRR^n$ & vector of joint angular velocities \\
%% $\d q \in \RRR^n$ & small step in joint angles \\
%% $y \in \RRR^d$ & some ``endeffector(s) feature(s)'' \newline
%% e.g.\ position $\in\RRR^3$ or vector $\in\RRR^3$ \\
%% $\phi:~ q \mapsto y$ & kinematic map \\
%% $J(q) = \frac{\del \phi}{\del q} \in \RRR^{d\times n}$ & Jacobian \\
%% $\norm{v}_W^2 = v^\T W v$ & squared norm of $v$ w.r.t.\ metric $W$
%% \end{tabular}

%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{Solution}{

%% \item Understand the \textbf{kinematics} of the robot: For given joint angles, where is the endeffector?

%% ~

%% \item Understand the \textbf{Jacobian}: When we change the joint
%% angles, how does the eff.\ change position?

%% ~

%% \item Define \textbf{optimality criteria}: What is the optimal change
%% in joint angles to achieve a \emph{desired} change in eff.\ position?

%% ~

%% ~

%% \cen{$\too$\quad \emph{``Inverse Kinematics''}}
%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{3 ingredients}{

%% \show[.7]{invKin-3ingreedients}

%% ~

%% {\small
%% 1)~ When we know/set the joint angles $q$, where is the endeffector $y$?

%% 2)~ When we change the joint angles $\d q$, how does the eff.\ change
%% position $\d y$?

%% 3)~ When we \emph{want} a certain change $\d y$ in eff.\ position, how do
%% we have to change the joint angles $\d q$?
%% }

%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\key{Forward kinematics}
\slide{Kinematics}{

\show{kinematics-3}

\item A \emph{kinematic structure} is a graph (usually tree or chain)\\ of
rigid \textbf{links} and \textbf{joints}
$$
\TR{W}{\eff}(q)
 = \TR{W}{A}~ {\color{red}\TR{A}{A'}(q)}~
   \TR{A'}{B}~ {\color{red}\TR{B}{B'}(q)}~
   \TR{B'}{C}~ {\color{red}\TR{C}{C'}(q)}~
   \TR{C'}{\eff}
$$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Joint types}
\slide{Joint types}{
  
\item Joint transformations:~ ${\color{red}\TR{A}{A'}(q)}$
\quad depends on $q\in\RRR^n$

~

revolute joint: joint angle $q\in\RRR$ determines rotation about $x$-axis:
\begin{align*}
\TR{A}{A'}(q) = \mat{cccc}{
1 & 0 & 0 & 0 \\
0 & \cos(q) & -\sin(q) & 0 \\
0 &  \sin(q) & \cos(q) & 0 \\
0 & 0 & 0 & 1}
\end{align*}

prismatic joint: offset $q\in\RRR$ determines translation along $x$-axis:
\begin{align*}
\TR{A}{A'}(q) = \mat{cccc}{
1 & 0 & 0 & q \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1}
\end{align*}

others: screw (1dof), cylindrical (2dof), spherical (3dof), universal
(2dof)

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{}{

\show{joint_types}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Kinematic map}
\slide{Kinematic Map}{

~

\item For any joint angle vector $q\in\RRR^n$ we can compute
  $\TR{W}{\eff}(q)$\\ by \emph{forward chaining} of transformations

~

$\TR{W}{\eff}(q)$ gives us the \emph{pose} of the endeffector in the world frame

~\mypause

\item In general, a kinematic map is \emph{any} (differentiable)
mapping
$$\phi:~ q \mapsto y$$

that maps to \emph{some arbitrary feature}
$y\in\RRR^d$ of the pose $q \in \RRR^n$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Kinematic Map}{

\item The three most important examples for a \emph{kinematic map} $\phi$ are
\begin{items}
\item A position $v$ on the endeffector transformed to world coordinates:
$$\phi^\pos_{\eff,v}(q) = \TR{W}{\eff}(q)~ v \quad \in \RRR^3$$
\item A direction $v\in\RRR^3$ attached to the endeffector in world coordinates:
$$\phi^\veC_{\eff,v}(q) = \RO{W}{\eff}(q)~ v\quad\in \RRR^3$$
Where $\RO{A}{ B}$ is the rotation in $\TR{A}{B}$.
\item The (quaternion) orientation $q\in\RRR^4$ of the endeffector:
$$\phi^\quat_{\eff}(q) = \RO{W}{\eff}(q) \quad\in \RRR^4$$
\end{items}

~

\item See the technical reference later for more kinematic maps, especially \emph{relative} position, direction and quaternion maps.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Jacobian}
\slide{Jacobian}{

\item When we change the joint angles, $\d q$, how does the effector
position change, $\d y$?

~

\item Given the kinematic map $y = \phi(q)$ and its Jacobian
$J(q) = \frac{\del}{\del q}\phi(q)$, we have:
$$\d y = J(q)~ \d q$$

$$
J(q) = \frac{\del}{\del q}\phi(q)
 = \mat{cccc}{
\de{\phi_1(q)}{q_1} & \de{\phi_1(q)}{q_2} & \dots & \de{\phi_1(q)}{q_n} \\
\de{\phi_2(q)}{q_1} & \de{\phi_2(q)}{q_2} & \dots & \de{\phi_2(q)}{q_n} \\
\vdots & & & \vdots \\
\de{\phi_d(q)}{q_1} & \de{\phi_d(q)}{q_2} & \dots & \de{\phi_d(q)}{q_n} } 
\qquad\in\RRR^{d\times n}
$$


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Jacobian for a rotational degree of freedom}{

\show[.5]{kinematics-4}

\item Assume the $i$-th joint is located at $p_i=t_{W\rightarrow i}(q)$ and has
rotation axis $a_i = \RO{W}{ i}(q)\mat{c}{1\\0\\0}$


\item We consider an infinitesimal variation $\d q_i \in \RRR$ of the $i$th
joint and see how an endeffector position
$p_\eff = \phi^\pos_{\eff,v}(q)$ and attached vector
$a_\eff = \phi^\veC_{\eff,v}(q)$ change.
%%  It must hold
%% $$
%% \d p_\eff = \underbrace{J^\pos_\eff(q)_{\cdot i}}_{\text{$i$th column}}~ \d q_i \qquad 
%% \d a_\eff = J^\veC_\eff(q)_{\cdot i}~ \d q_i
%% $$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Jacobian for a rotational degree of freedom}{
\hspace*{-10mm}\twocol{.6}{.4}{
\show[.9]{kinematics-4}
}{

Consider a variation $\d q_i$

$\to$ the whole sub-tree rotates

~

{\color{red}$\d p_\eff = [a_i \times (p_\eff - p_i)]~ \d q_i $}

{\color{red}$\d a_\eff = [a_i \times a_\eff]~ \d q_i $}

}

~

~

\hspace*{-10mm}\twocol{.55}{.5}{
$\To$ Position Jacobian:\\[-5ex]
\begin{align*}
J^\pos_{\eff,v}(q) = \mat{cccc}{
\rotatebox{90}{$[a_1\times(p_\eff - p_1)]~$} &
\rotatebox{90}{$[a_2\times(p_\eff - p_2)]~$} &
\rotatebox{90}{\qquad\vdots\qquad} &
\rotatebox{90}{$[a_n\times(p_\eff - p_n)]~$}
}~
 \in\RRR^{3\times n}
\end{align*}
}{
$\To$ Vector Jacobian:\\[-5ex]
\begin{align*}
J^\veC_{\eff,v}(q) = \mat{cccc}{
\rotatebox{90}{$[a_1\times a_\eff]~$} &
\rotatebox{90}{$[a_2\times a_\eff]~$} &
\rotatebox{90}{\qquad\vdots\qquad} &
\rotatebox{90}{$[a_n\times a_\eff]~$}
}
~ \in\RRR^{3\times n}
\end{align*}
}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Jacobian for general degrees of freedom}{

\item Every degree of freedom $q_i$ generates (infinitesimally, at a given $q$)
\begin{items}
\item a rotation around axis $a_i$ at point $p_i$
\item \emph{and/or} a translation along the axis $b_i$
\end{items}

For instance:
\begin{items}
\item the DOF of a hinge joint just creates a rotation around $a_i$ at $p_i$
\item the DOF of a prismatic joint creates a translation along $b_i$
\item the DOF of a rolling cylinder creates rotation \emph{and} translation
\item the first DOF of a cylindrical joint generates a translation, its second DOF a translation
\end{items}

~

\item We can compute all Jacobians from knowing $a_i$, $p_i$ and $b_i$ for all DOFs (in the current configuration $q\in\RRR^n$)

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sublecture{Inverse Kinematics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Inverse Kinematics problem}{

\item Generally, the aim is to find a robot configuration $q$ such
that $\phi(q)=y^*$

\item Iff $\phi$ is invertible
$$ q^* = \phi^\1 (y^*) $$

~

\item But in general, $\phi$ will not be invertible:

~

1) The pre-image $\phi^\1(y^*) = \empty$ may be empty: No
configuration can generate the desired $y^*$

~

2) The pre-image $\phi^\1(y^*)$ may be large: many configurations can
generate the desired $y^*$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Inverse kinematics as optimization problem}
\slide{Inverse Kinematics as optimization problem}{

\item We formalize the inverse kinematics problem as an optimization problem
$$q^* = \argmin_q \norm{\phi(q) - y^*}^2_C + \norm{q-q_0}^2_W $$

~

\item The 1st term ensures that we find a configuration even if $y^*$ is not
exactly reachable

The 2nd term disambiguates the configurations if there are many $\phi^\1(y^*)$

~

\show[.4]{optim-InvKin-2}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Inverse Kinematics as optimization problem}{

$$q^* = \argmin_q \norm{\phi(q) - y^*}^2_C + \norm{q-q_0}^2_W $$

~

\item The formulation of IK as an optimization problem is very
powerful and has many nice properties

\item We will be able to take the limit $C\to\infty$,
enforcing exact $\phi(q) = y^*$ if possible

\item Non-zero $C^\1$ and $W$ corresponds to a regularization
that ensures numeric stability

\item Classical concepts can be derived as special cases:
\begin{items}
\item Null-space motion
\item regularization; singularity robutness
\item multiple tasks
\item hierarchical tasks
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Solving Inverse Kinematics}{

\item The obvious choice of optimization method for this problem is
Gauss-Newton, using the Jacobian of $\phi$

\item We first describe just one step of this, which leads to the
classical equations for inverse kinematics using the local Jacobian...

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Inverse kinematics solution}
\slide{Solution using the local linearization}{

\item When using the local linearization of $\phi$ at $q_0$,
$$ \phi(q) \approx y_0 + J~(q-q_0) \comma y_0 = \phi(q_0)$$

\item We can derive the optimum as
{\small\begin{align*}
f(q)
&= \norm{\phi(q) - y^*}^2_C + \norm{q-q_0}^2_W \\
&= \norm{y_0-y^* + J~(q-q_0)}^2_C + \norm{q-q_0}^2_W \\
\frac{\del}{\del q} f(q)
&= 0^\T = 2 (y_0-y^* + J~(q-q_0))^\T C J + 2(q-q_0)^T W \\
J^\T C~ (y^*-y_0)
&= (J^\T C J+W)~(q-q_0)
\end{align*}

}
\eqbox{$q^* = q_0 +  J^\sharp (y^*-y_0)$}
\medskip

{\small with $J^\sharp = (J^\T C J + W)^\1 J^\T C = W^\1 J^\T (J W^\1 J^\T +
C^\1)^\1$ (\emph{Woodbury identity})}

~

\begin{items}
\item For $C\to\infty$ and $W=\Id$, $J^\sharp = J^\T (J J^\T)^\1$ is called
\emph{pseudo-inverse}

\item $W$ generalizes the metric in $q$-space

\item $C$ regularizes this pseudo-inverse (see later section on
singularities)
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{``Small step'' application}{

\item This approximate solution to IK makes sense
\begin{items}
\item if the local linearization of $\phi$ at $q_0$ is ``good''
\item if $q_0$ and $q^*$ are close
\end{items}

\item This equation is therefore typically used to iteratively compute
small steps in configuration space
$$q_{t\po} = q_t +  J^\sharp (y_{t\po}^*-\phi(q_t))$$
where the target $y_{t\po}^*$ moves smoothly with $t$

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Example: Iterating IK to follow a trajectory}{

\item Assume initial posture $q_0$. We want to reach a desired
endeff position $y^*$ in $T$ steps:

\begin{algo}
\Require initial state $q_0$, desired $y^*$, methods
  $\phi^\pos$ and $J^\pos$
\Ensure trajectory $q_{0:T}$
\State Set $y_0 = \phi^\pos(q_0)$ \Comment{starting endeff position}
\For{$t=1:T$}
\State $y \gets \phi^\pos(q_{t\1})$ \Comment{current endeff position}
\State $J \gets J^\pos(q_{t\1})$ \Comment{current endeff Jacobian}
\State $\hat y \gets y_0 + (t/T)(y^*-y_0)$ \Comment{interpolated endeff target}
\State $q_t = q_{t\1} + J^\sharp(\hat y - y)$ \Comment{new joint
  positions}
\State Command $q_t$ to all robot motors and compute all $\TR{W}{i}(q_t)$
\EndFor
\end{algo}

{\hfill\tiny\texttt{01-kinematics: ./x.exe -mode 2/3}}

~\mypause

\item Why does this not follow the interpolated trajectory $\hat
y_{0:T}$ exactly?

-- What happens if $T=1$ and $y^*$ is far?

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Two additional notes}{

\item What if we linearize at some arbitrary $q'$ instead of $q_0$?
{\small\begin{align}
\phi(q)
 & \approx y' + J~(q-q') \comma y' = \phi(q') \nonumber\\
q^*
&= \argmin_q \norm{\phi(q) - y^*}^2_C + \norm{q-q'+(q'-q_0)}^2_W \nonumber\\
&= q' + J^\sharp~ (y^*-y') + (I - J^\sharp J)~ h \comma h=q_0 - q'
\end{align}
}
%Note that $h$ corresponds to the classical concept of \emph{null space
%motion}

~

\item What if we want to find the \emph{exact} (local) optimum? E.g.\
what if we want to compute a big step (where $q^*$ will be remote from
$q$) and we cannot not rely only on the local linearization
approximation?
\begin{items}
\item Iterate equation (1) (optionally with a step size $<1$ to ensure
convergence) by setting the point $y'$ of linearization to the current
$q^*$

\item This is equivalent to the Gauss-Newton algorithm
\label{IKgn}
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Where are we?}{

\item We've derived a basic motion generation principle
in robotics from

-- an understanding of robot geometry \& kinematics

-- a basic notion of optimality

~\mypause

\item In the remainder:

{\small

A.~ Discussion of classical concepts
%% \begin{items}
%% \item Singularity and singularity-robustness
%% \item Nullspace, task/operational space, joint space
%% \item ``inverse kinematics'' $\oto$ ``motion rate control''
%% \end{items}

B.~ Heuristic motion profiles for simple trajectory generation

C.~ Extension to multiple task variables


%% trakectories in task/operational space vs joint space

%% How? Projecting it down.
%% trajectory profiles

}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Discussion of classical concepts}{

~

\begin{items}
\item Singularity and singularity-robustness
\item Nullspace, task/operational space, joint space
\item ``inverse kinematics'' $\oto$ ``motion rate control''
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Singularity}
\slide{Singularity}{

\item In general: A matrix $J$ \textbf{singular} $\iff$ $\rank(J)<d$
\begin{items}
\item rows of $J$ are linearly dependent
\item dimension of image is $< d$
\item $\d y = J \d q$ ~ $\To$ ~ dimensions of $\d y$ limited
\item Intuition: arm fully stretched
\end{items}

~\mypause

\item Implications:

$\det(J J^\T)=0$

\quad $\to$ ~ pseudo-inverse $J^\T (J J^\T)^\1$ is
  ill-defined!

\quad $\to$ ~ inverse kinematics $\d q = J^\T (J J^\T)^\1 \d y$
computes ``infinite'' steps!

~

\item \textbf{Singularity robust pseudo inverse} $J^\T (J J^\T + \e\Id)^\1$

The term $\e\Id$ is called \textbf{regularization}

\item Recall our general solution (for $W=\Id$)

\cen{$J^\sharp = J^\T (J J^\T + C^\1)^\1$}

is already singularity robust

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Null space, task space, operational space, joint space}
\slide{Null/task/operational/joint/configuration spaces}{

\item The space of all $q\in\RRR^n$ is called \textbf{joint/configuration
space}

The space of all $y\in\RRR^d$ is called \textbf{task/operational space}

Usually $d<n$, which is called \textbf{redundancy}

~\mypause

\item For a desired endeffector state $y^*$ there exists a whole
manifold (assuming $\phi$ is smooth) of joint configurations $q$:

$$\textbf{nullspace}(y^*) = \{ q ~|~ \phi(q) = y^* \} $$

~

\item We have
\begin{align*}
\d q
&= \argmin_q \norm{q-a}^2_W + \norm{J q - \d y}^2_C\\
&= J^\# \d y + (\Id - J^\# J) a
\comma
J^\# = W^\1 J^\T (J W^\1 J^\T + C^\1)^\1
\end{align*}
In the limit $C\to\infty$ it is guaranteed that $J \d q=\d y$ (we are
exacty on the manifold). The term $a$ introduces additional
``nullspace motion''.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Motion rate control}
\slide{Inverse Kinematics and Motion Rate Control}{

Some clarification of concepts:

~

\item The notion ``kinematics'' describes the mapping $\phi:~ q\mapsto y$,
which usually is a many-to-one function.

\item The notion ``inverse kinematics'' in the strict sense describes
some mapping $g:~ y \mapsto q$ such that $\phi(g(y))=y$, which usually is
non-unique or ill-defined.

\item In practice, one often refers to $\d q = J^\sharp \d y$ as
\textbf{inverse kinematics}.

~

\item When iterating $\d q = J^\sharp \d y$ in a control cycle with
time step $\tau$ (typically $\tau \approx 1-10$ msec), then $\dot y
= \d y/\tau$ and $\dot q = \d q/\tau$ and $\dot q = J^\sharp \dot
y$. Therefore the control cycle effectively controls the endeffector
velocity---this is why it is called \textbf{motion rate control}.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Heuristic motion profiles}{
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Sine motion profile}
\slide{Heuristic motion profiles}{

\item Assume initially $x=0,\dot x=0$. After 1 second you want
$x=1,\dot x=0$.

How do you move from $x=0$ to $x=1$ in one second?

~

%\hspace*{-9mm}
\showh[.45]{motion1}
\showh[.45]{motion2}

%\hspace*{-9mm}
\showh[.45]{motion4}
\showh[.45]{motion3}

The sine profile $x_t = x_0 + \half [1-\cos(\pi t/T)](x_T-x_0)$ is a compromise
for low max-acceleration and max-velocity

{\tiny Taken from
\url{http://www.20sim.com/webhelp/toolboxes/mechatronics_toolbox/motion_profile_wizard/motionprofiles.htm}}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Motion profiles}{

\item Generally, let's define a motion profile as a mapping
$$\text{MP}: [0,1] \mapsto [0,1]$$ with $\text{MP}(0)=0$ and
$\text{MP}(1)=1$ such that the interpolation is given as
$$x_t = x_0 + \text{MP}(t/T)~ (x_T-x_0)$$

~

\item For example
\begin{align*}
\text{MP}_\text{ramp}(s)
 &= s \\
\text{MP}_\text{sin}(s)
 &= \half [1-\cos(\pi s)]
\end{align*}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Joint space trajectory interpolation}
\slide{Joint space interpolation}{

~

\item[1)] Optimize a desired final configuration $q_T$:

{\small
Given a desired final task value $y_T$, optimize a final joint state
$q_T$ to minimize the function
$$f(q_T) = \norm{q_T-q_0}^2_{W/T} + \norm{y_T - \phi(q_T)}^2_C$$

-- The metric $\frac{1}{T}W$ is consistent with
$T$ cost terms with step metric $W$.

-- In this optimization, $q_T$ will end up remote from $q_0$. So we
need to iterate Gauss-Newton, as described on slide \ref{IKgn}.

}

~

\item[2)] Compute $q_{0:T}$ as interpolation between $q_0$ and $q_T$:

{\small Given the initial configuration $q_0$ and the final $q_T$,
interpolate on a straight line with a some motion profile. E.g.,

$$q_t = q_0 + \text{MP}(t/T)~ (q_T-q_0)$$

}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Task space trajectory interpolation}
\slide{Task space interpolation}{

~

\item[1)] Compute $y_{0:T}$ as interpolation between $y_0$ and $y_T$:

{\small
Given a initial task value $y_0$ and a desired final task value
$y_T$, interpolate on a straight line with a some motion profile. E.g,

$$y_t = y_0 + \text{MP}(t/T)~ (y_T-y_0)$$

}

~

\item[2)] Project $y_{0:T}$ to $q_{0:T}$ using inverse kinematics:

{\small
Given the task trajectory $y_{0:T}$, compute a corresponding joint
trajectory $q_{0:T}$ using inverse kinematics
$$q_{t\po} = q_t + J^\sharp(y_{t\po} - \phi(q_t))$$
(As steps are small, we should be ok with just using this local
linearization.)

}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{}{

\texttt{peg-in-a-hole demo}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sublecture{Multiple tasks}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Multiple tasks}{

\shows[.5]{marionette-Tasks-1}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Multiple tasks}{

\shows[.5]{marionette-Tasks-2}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{The 'big' task vector}
\slide{Multiple tasks}{

\item Assume we have $m$ simultaneous tasks; for each task $i$ we have:
\begin{items}
\item a kinematic map $\phi_i:~ \RRR^n \to \RRR^{d_i}$
\item a current value $\phi_i(q_t)$
\item a desired value $y_i^*$
\item a precision $\r_i$ ~~ (equiv.\ to a task cost metric $C_i =  \r_i~ \Id$)
\end{items}

~\mypause

\item Each task contributes a term to the objective function
\begin{align*}
q^*
&= \argmin_q \norm{q-q_0}_W^2
 + \r_1~ \norm{\phi_1(q) - y_1^*}^2
 + \r_2~ \norm{\phi_2(q) - y_2^*}^2 + \cdots
\end{align*}
\mypause
which we can also write as
\begin{align*}
q^*
&= \argmin_q
   \norm{q-q_0}_W^2
 + \norm{\Phi(q)}^2 \\
&\text{where~} \Phi(q)
 := \mat{c}{
  \sqrt{\r_1}~ (\phi_1(q) - y_1^*) \\
  \sqrt{\r_2}~ (\phi_2(q) - y_2^*) \\
  \vdots
} \quad\in\RRR^{\sum_i d_i}
\end{align*}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Inverse kinematics for all tasks}
\slide{Multiple tasks}{

\item We can ``pack'' together all tasks in one ``big task''
 $\Phi$.

~

{\small Example: We want to control the 3D position of the left hand
and of the right hand. Both are ``packed'' to one 6-dimensional task
vector which becomes zero if both tasks are fulfilled.\\}

~

\item The big $\Phi$ is scaled/normalized in a way that
\begin{items}
\item the desired value is always zero
\item the cost metric is $\Id$
\end{items}

~

\item Using the local linearization of $\Phi$ at $q_0$,
$J=\frac{\del\Phi(q_0)}{\del q}$, the optimum is
\begin{align*}
q^*
 &= \argmin_q \norm{q-q_0}_W^2 + \norm{\Phi(q)}^2 \\
 &\approx q_0 - (J^\T J + W)^\1 J^\T~ \Phi(q_0)
 =q_0 - J^\# \Phi(q_0)
\end{align*}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{Multiple tasks}{

~

\hspace*{-5mm}\twocol[.05]{.4}{.5}{
\show{marionette-Tasks-2}
}{

\item We learnt how to ``puppeteer a robot''

\item We can handle many task variables (but specifying their
precisions $\r_i$ becomes cumbersome...)

~

\item In the remainder:

{\small

A.~ Classical limit of ``hierarchical IK'' and nullspace motion

B.~ What are interesting task variables?

}

}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Hierarchicak inverse kinematics, nullspace motion}
\slide{Hierarchical IK \& nullspace motion}{

\small

\item In the classical view, tasks should be executed \emph{exactly},
which means taking the limit $\r_i\to\infty$ in some prespecified
hierarchical order.

\item We can rewrite the solution in a way that allows for such a hierarchical
limit:

\item One task plus ``nullspace motion'':
\begin{align*}
f(q)
&= \norm{q-a}^2_W + \r_1 \norm{J_1 q - y_1}^2\\
%&\propto \norm{q-\hat a}^2_{\widehat W} \\
q^*
&= [W + \r_1 J_1^\T J_1]^\1~ [W a + \r_1 J_1^\T y_1] \\
&= J_1^\# y_1 + (\Id - J_1^\# J_1) a \\
J_1^\#
 &= (W/\r_1 + J_1^\T J_1)^\1 J_1^\T 
  = W^\1 J_1^\T (J_1 W^\1 J_1^\T + \Id/\r_1)^\1
\end{align*}

\item Two tasks plus nullspace motion:
\begin{align*}
f(q)
&= \norm{q-a}^2_W + \r_1 \norm{J_1 q - y_1}^2 + \r_2 \norm{J_2 q - y_2}^2\\
%&= \norm{q-\hat a}^2_{\widehat W} + \norm{J_1 q + \Phi_1}^2\\
q^*
&= J_1^\# y_1 + (\Id - J_1^\# J_1)[J_2^\# y_2 + (\Id - J_2^\# J_2) a] \\
J_2^\#
 &=  (W/\r_2 + J_2^\T J_2)^\1 J_2^\T
  = W^\1 J_2^\T (J_2 W^\1 J_2^\T + \Id/\r_2)^\1
\end{align*}

\item etc...

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Hierarchical IK \& nullspace motion}{

\item The previous slide did nothing but rewrite the nice solution
$q^* = - J^\# \Phi(q_0)$ (for the ``big'' $\Phi$) in a strange hierarchical
way that allows to ``see'' nullspace projection

~

\item The benefit of this hierarchical way to write the solution is that
one can take the hierarchical limit $\r_i\to\infty$ and retrieve
classical hierarchical IK

~

\item The drawbacks are:
\begin{items}
\item It is somewhat ugly

\item In practise, I would recommend regularization in any case (for
numeric stability). Regularization corresponds to NOT taking the full
limit $\r_i\to\infty$. Then the hierarchical way to write the solution
is unnecessary. (However, it points to a ``hierarchical
regularization'', which might be numerically more robust for very
small regularization?)

\item The general solution allows for arbitrary blending of tasks
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\key{Reference of task maps and their Jacobians}
\slide{Reference: interesting task variables}{

~

The following slides will define 10 different types of task variables.

This is meant as a reference and to give an idea of possibilities...

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Position}{

\begin{tabular}{|p{.18\columnwidth}|p{.6\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Position of some point attached to link $i$}\\
\hline
dimension & $d=3$ \\
\hline
parameters & link index $i$, point offset $v$ \\
\hline
kin.\ map & $\phi^\pos_{iv}(q) = \TR{W}{i}~ v$ \\
\hline
Jacobian & $J^\pos_{iv}(q)_{\cdot k} = [k\prec i]~ a_k \times(\phi^\pos_{iv}(q) - p_k)$ \\
\hline
\end{tabular}

~

~

\tiny

Notation:
\begin{items}
\item $a_k,p_k$ are axis and position of joint $k$
\item $[k\prec i]$ indicates whether joint $k$ is between root and
link $i$
\item $J_{\cdot k}$ is the $k$th column of $J$
\end{items}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Vector}{

\begin{tabular}{|p{.18\columnwidth}|p{.6\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Vector attached to link $i$}\\
\hline
dimension & $d=3$ \\
\hline
parameters & link index $i$, attached vector $v$ \\
\hline
kin.\ map & $\phi^\veC_{iv}(q) = \RO{W}{ i}~ v$ \\
\hline
Jacobian & $J^\veC_{iv}(q) = A_i\times \phi^\veC_{iv}(q)$ \\
\hline
\end{tabular}

~

~

\tiny

Notation:
\begin{items}
\item $A_i$ is a matrix with columns $(A_i)_{\cdot k} = [k \prec i]~
a_k$ containing the joint axes or zeros
\item the short notation ``$A\times p$'' means that
   each \emph{column} in $A$ takes the cross-product with $p$.
\end{items}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Relative position}{

\hspace*{-5mm}\begin{tabular}{|p{.15\columnwidth}|p{.75\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Position of a point on link $i$ relative to point
on link $j$}\\
\hline
dimension & $d=3$ \\
\hline
parameters & link indices $i,j$, point offset $v$ in $i$ and $w$ in $j$\\
\hline
kin.\ map & $\phi^\pos_{iv|jw}(q) = R_j^\1
(\phi^\pos_{iv} - \phi^\pos_{jw})$ \\
\hline
Jacobian   & $J^\pos_{iv|jw}(q)
 = R_j^\1 [J^\pos_{iv}-J^\pos_{jw} -
 A_j \times (\phi^\pos_{iv} - \phi^\pos_{jw})]$ \\
\hline
\end{tabular}

~

~

\tiny

Derivation:

For $y=R p$ the derivative w.r.t.\ a rotation around axis $a$ is $y' =
R p' + R' p = R p' + a \times R p$. For $y=R^\1 p$ the derivative is
$y' = R^\1 p' - R^\1 (R') R^\1 p = R^\1 (p' - a \times p)$.  (For
details
see \url{http://ipvs.informatik.uni-stuttgart.de/mlr/marc/notes/3d-geometry.pdf})

~


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Relative vector}{

\hspace*{-5mm}\begin{tabular}{|p{.18\columnwidth}|p{.7\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Vector attached to link $i$ relative to link $j$}\\
\hline
dimension & $d=3$ \\
\hline
parameters & link indices $i,j$, attached vector $v$ in $i$\\
\hline
kin.\ map & $\phi^\veC_{iv|j}(q) = R_j^\1 \phi^\veC_{iv}$ \\
\hline
Jacobian   & $J^\veC_{iv|j}(q)
 = R_j^\1 [J^\veC_{iv} -
 A_j \times \phi^\veC_{iv}]$ \\
\hline
\end{tabular}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Alignment}{

\begin{tabular}{|p{.18\columnwidth}|p{.65\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Alignment of a vector attached to link $i$ with a reference $v^*$}\\
\hline
dimension & $d=1$ \\
\hline
parameters & link index $i$, attached vector $v$, world reference $v^*$ \\
\hline
kin.\ map & $\phi^\text{align}_{iv}(q) = v^*{}^\T~ \phi^\veC_{iv}$ \\
\hline
Jacobian   & $J^\text{align}_{iv}(q)
 = v^*{}^\T~ J^\veC_{iv}$ \\
\hline
\end{tabular}

~

~

\tiny

Note: \quad $\phi^\text{align}=1 \oto $ align \quad $\phi^\text{align}=-1 \oto $ anti-align \quad $\phi^\text{align}=0 \oto $ orthog.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Relative Alignment}{

\begin{tabular}{|p{.18\columnwidth}|p{.65\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Alignment a vector attached to link $i$ with
vector attached to $j$}\\
\hline
dimension & $d=1$ \\
\hline
parameters & link indices $i,j$, attached vectors $v,w$ \\
\hline
kin.\ map & $\phi^\text{align}_{iv|jw}(q) = (\phi^\veC_{jw})^\T~ \phi^\veC_{iv}$ \\
\hline
Jacobian   & $J^\text{align}_{iv|jw}(q) = (\phi^\veC_{jw})^\T~
J^\veC_{iv} +\phi^\veC_{iv}{}^\T~ J^\veC_{jw}$ \\
\hline
\end{tabular}

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Joint limits}{

\hspace*{-5mm}\begin{tabular}{|p{.18\columnwidth}|p{.7\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Penetration of joint limits}\\
\hline
dimension & $d=1$ \\
\hline
parameters & joint limits $q_{\text{low}}, q_{\text{hi}}$, margin
$m$ \\
\hline
kin.\ map & $\phi_{\text{limits}}(q) = \frac{1}{m}\sum_{i=1}^n
[m-q_i+q_{\text{low}}]^+ + [m+q_i-q_{\text{hi}}]^+$ \\
\hline
Jacobian   & $J_{\text{limits}}(q)_{1,i}
 = - \frac{1}{m}[m-q_i+q_{\text{low}}>0] + \frac{1}{m}[m+q_i-q_{\text{hi}}>0]$ \\
\hline
\end{tabular}

~

~

\small

$[x]^+ = x>0\text{?}x:0$ \qquad $[\cdots]$: indicator function

\anchor{20,-70}{\showh[.3]{col}}

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Collision limits}{

\begin{tabular}{|p{.18\columnwidth}|p{.6\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Penetration of collision limits}\\
\hline
dimension & $d=1$ \\
\hline
parameters & margin $m$ \\
\hline
kin.\ map & $\phi_{\text{col}}(q) = \frac{1}{m}\sum_{k=1}^K
[m-|p^a_k - p^b_k|]^+$ \\
\hline
Jacobian   & $J_{\text{col}}(q)
 = \frac{1}{m} \sum_{k=1}^K [m-|p^a_k - p^b_k|>0]$\newline
\mbox{}\hfill $(- J^\pos_{p^a_k} + J^\pos_{p^b_k})^\T \frac{p^a_k - p^b_k}{|p^a_k - p^b_k|}$ \\
\hline
\end{tabular}

~

~

\small

A collision detection engine returns a set $\{
(a,b,p^a,p^b)_{k=1}^K \}$ of potential collisions between link $a_k$
and $b_k$, with nearest points $p^a_k$ on $a$ and $p^b_k$ on $b$.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Center of gravity}{

\begin{tabular}{|p{.18\columnwidth}|p{.6\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{Center of gravity of the whole kinematic structure}\\
\hline
dimension & $d=3$ \\
\hline
parameters & (none) \\
\hline
kin.\ map & $\phi^{\text{cog}}(q) = \sum_i \text{mass}_i~ \phi^\pos_{ic_i}$ \\
\hline
Jacobian   & $J^{\text{cog}}(q) = \sum_i \text{mass}_i~ J^\pos_{ic_i}$ \\
\hline
\end{tabular}

~

~

\tiny

$c_i$ denotes the center-of-mass of link $i$ (in its own frame)

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Homing}{

\begin{tabular}{|p{.18\columnwidth}|p{.6\columnwidth}|}
\hline
%\rowcolor[gray]{.9}
\multicolumn{2}{|c|}{The joint angles themselves}\\
\hline
dimension & $d=n$ \\
\hline
parameters & (none) \\
\hline
kin.\ map & $\phi_{\text{qitself}}(q) = q$ \\
\hline
Jacobian   & $J_{\text{qitself}}(q) = \Id_n$ \\
\hline
\end{tabular}

~

~

\small

Example: Set the target $y^*=0$ and the precision $\r$ very low $\to$
this task describes posture comfortness in terms of deviation from the
joints' zero position. In the classical view, it induces ``nullspace motion''.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\slide{Task variables -- conclusions}{

~

\hspace*{-10mm}\twocol[.05]{.4}{.5}{
\showh[1]{marionette-Tasks-3}
}{

\small

\item There is much space for creativity in defining task
variables! Many are extensions of $\phi^\pos$ and
$\phi^\veC$ and the Jacobians combine the basic Jacobians.

~

\item What the \emph{right} task variables are to design/describe
motion is a very hard problem! In what task space do humans
control their motion? Possible to learn from data (``task space
retrieval'') or perhaps via Reinforcement Learning.

~

\item In practice: Robot motion design (including grasping) may require
cumbersome hand-tuning of such task variables.

}

}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{}{

%% \large\textbf{Heuristics for simple trajectory generation}

%% }

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{How do we get smooth trajectories?}{

%% \item So far, all our methods only look \emph{one} step ahead:

%% $f(q_{t\po})$ is a cost function for the \emph{next} joint step 

%% $\d q = J^\sharp \d y$ desribed the \emph{next} joint step 

%% ~

%% What if we want to have a nice \emph{trajectory} that smoothly
%% accelerates and comes to a halt at the target?

%% ~\mypause

%% \item Later lectures will cover path finding and trajectory optimization.

%% ~

%% Here we discuss common heuristics used in engineering that are quite
%% useful.

%% }

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \slide{Trajectory generation as interpolation}{

%% \item A \textbf{trajectory} $q_{0:T}$ is a sequence of robot configurations
%% $q_t \in\RRR^n$.

%% \begin{items}
%% \item This corresponds to $T\po$ \emph{time slices} but $T$ \emph{time
%%    steps} (or \emph{transitions})!
%% \item In software: typically stored as $(T\po)\times n$-matrix!
%% \end{items}

%% ~

%% \item The basic heuristic for trajectory generation: If you know a
%% desired start point $x_0$ and target point $x_T$, interpolate on a
%% straight line and choose a nice \textbf{motion profile}.

%% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\slide{}{\label{lastpage}

\item Technical Reference: The four rotation axes of a quaternion joint:

~

{\tiny

A quaternion joint has four DOFs. If it is currently in configuration $q\in\RRR^4$, the $i$th DOFs generates (infinitesimally) a rotation around the axis
$$a_i = \frac{-2}{\sqrt{q^2}}[e_i \circ q^\1]_{1:3}$$
where $e_i\in\RRR^4$ is the $i$th unit vector, $\circ$ is the concatenation of quaternions, $q^\1$ the inverse quaternion, $q^2$ the quaternion 2-norm (in case it is not normalized), and $[\cdot]_{1:3}$ pics the vector elements of the quaternion (derivation: see geometry notes). As for the hinge joint, these four axes are further transformed to world coordinates, $a_i \gets \RO{W}{j} a_i$, if the quaternion joint is located in the coordinate frame $j$.

}

}


\slidesfoot

