\input{../shared/shared}

\renewcommand{\course}{Artificial Intelligence}
\renewcommand{\coursepicture}{course_ai}
\renewcommand{\coursedate}{Winter 2019}
\renewcommand{\exnum}{7}

\exercises

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Die Lösungen bitte als python-Datei (siehe Vorlage in der
Email/Website) mit dem Namen @e07/e07_sol.py@ (in Verzeichnis @e07@)
in Euer git account einloggen. In der python-Datei wird das Format, in
dem Antworten gegeben werden sollen, genauer erklärt. Bei Unklarheiten
bitte bei dem Tutor melden.

Diese letzte Übung zählt zu den Programmieraufgaben. Dies ist keine
Bonusaufgabe. Präsenz- und Votieraufgaben gibt es nicht mehr.

Abgabe bis Montag, 20. Februar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exsection{Erfüllbarkeit und allgemeine Gültigkeit (Aussagenlogik) (30\%)}

Entscheiden Sie, ob die folgenden S"atze erf"ullbar (\emph{satisfiable}),
allgemein g"ultig (\emph{valid}) oder keins von beidem (\emph{none})
sind. 

\begin{enumerate}
\item[(a)] $Smoke \Rightarrow Smoke$
\item[(b)] $Smoke \Rightarrow Fire$
\item[(c)] $(Smoke \Rightarrow Fire) \Rightarrow (\neg Smoke \Rightarrow \neg Fire)$
\item[(d)] $Smoke \vee Fire \vee \neg Fire$
\item[(e)] $((Smoke \wedge Heat) \Rightarrow Fire) \Leftrightarrow ((Smoke \Rightarrow Fire) \vee (Heat \Rightarrow Fire))$
\item[(f)] $(Smoke \Rightarrow Fire) \Rightarrow ((Smoke \wedge Heat) \Rightarrow Fire)$
\item[(g)] $Big \vee Dumb \vee (Big \Rightarrow Dumb)$
\item[(h)] $(Big \wedge Dumb) \vee \neg Dumb$
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exsection{Modelle enumerieren (Aussagenlogik) (30\%)}

Betrachten Sie die Aussagenlogik mit Symbolen $A$, $B$, $C$ und
$D$. Insgesamt existieren also 16 Modelle. In wievielen Modellen sind die folgenden S"atze erf"ullt?
\begin{enumerate}
\item $(A \wedge B) \vee (B \wedge  C)$
\item $A \vee B$
\item $A \Leftrightarrow (B \Leftrightarrow C)$
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exsection{Unifikation (Prädikatenlogik) (40\%)}

Geben Sie f"ur jedes Paar von atomaren S"atzen den allgemeinsten
Unifikator an, sofern er existiert. Standardisieren Sie nicht
weiter. Geben Sie None zurück, wenn kein Unifikator
existiert. Ansonsten ein Dictioary, dass als Key die Variable und als
Value die Konstante enthält.

Für $P(A), P(x)$: \qquad @sol3z = {'x': 'A'}@

\begin{enumerate}
\item $P(A,B,B), P(x,y,z)$.
\item $Q(y,G(A,B)), Q(G(x,x),y)$.
\item $Older(Father(y),y), Older(Father(x), John)$.
\item $Knows(Father(y),y), Knows(x, x)$.
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exsection{Privat-Spaß-Aufgabe: as Constraint Satisfaction
Problem}

Consider the Generalized Modus Ponens (slide 09:15) for inference
(forward and backward chaining) in first order logic. Applying this
inference rule requires to find a substitution $\t$ such that
$p_i'\t = p_i\t$ for all $i$.

Show constructively that the problem of finding a substitution $\t$
(also called \textbf{matching problem}) is equivalent to a Constraint
Satisfaction Problem. ``Constructively'' means, explicitly
construct/define a CSP that is equivalent to the matching problem.

Note: The PDDL language to describe agent planning problems (slide
08:24) is similar to a knowledge in Horn form. Checking whether the
action preconditions hold in a given situation is exactly the matching
problem; applying the Generalized Modus Ponens corresponds to the
application of the action rule on the current situation.




%% \begin{itemize}
%% \item[(a)]  ({\bf 2 Punkte})\\
%% Ist der Satz $\exists x,y$ $x = y$ g"ultig? Erkl"aren Sie Ihre Antwort!

%% \item[(b)]  ({\bf 3 Punkte})\\
%% Dr"ucken Sie den Satz 'Alle Deutschen sprechen die gleichen Sprachen' in Pr"adikatenlogik aus.

%% \item[(c)]  ({\bf 3 Punkte})\\
%% Welches Axiom ist n"otig um den Fakt $Weiblich(Laura)$ aus den Fakten $M"annlich(Jim)$ und $Ehegatte(Jim,Laura)$ zu folgern?

%% \item[(d)]  ({\bf 4 Punkte})\\
%% Betrachten Sie eine Wissensbasis, die lediglich zwei S"atze enth"alt: $P(a)$ und $P(b)$. Impliziert diese Wissensbasis $\forall x$ $P(x)$? Erkl"aren Sie Ihre Antwort unter Verwendung von Modellen.
%% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\exsection{Privat-Spaß-Aufgabe}

In the lecture we discussed the case

``A first cousin is a child of a parent's sibling''

$$\forall{x,y}~ FirstCousin(x,y) \iff 
\exists{p,z}~ Parent(p,x) \land Sibling(z,p) \land Parent(z,y)$$

A question is whether this is equivalent to

$$\forall{x,y,p,z}~ FirstCousin(x,y) \iff Parent(p,x) \land
  Sibling(z,p) \land Parent(z,y)$$

Let's simplify: Show that the following two
\begin{align}
\forall x~ A(x) \iff \exists y~ B(y,x) \\
\forall x,y~ A(x) \iff B(y,x)
\end{align}
are different. For this, bring both sentences in CNF as described on
slides 09:21 and 09:22 of lecture 09-FOLinference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\exerfoot
